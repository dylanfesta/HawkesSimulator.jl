var documenterSearchIndex = {"docs":
[{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"EditURL = \"https://github.com/dylanfesta/HawkesSimulator.jl/blob/master/examples/alphadelay.jl\"","category":"page"},{"location":"alphadelay/#D-Hawkes-process-with-delayed-alpha-kernel","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"","category":"section"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"In this example, I simulate either a 1D or a 2D Hawkes process, with a delayed-alpha interaction kernel","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"g(t) = H(t-t_textdelay)   frac(t-t_textdelay)tau^2 \n expleft(- frac(t-t_textdelay)tau right)","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"where H(x) is the Heaviside function: H(x)=0 for x0, H(x)=1 for tgeq 0.","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"Kernels are always normalized so that their integral is 1.","category":"page"},{"location":"alphadelay/#Initialization","page":"1D Hawkes process with delayed alpha kernel","title":"Initialization","text":"","category":"section"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"using LinearAlgebra,Statistics,StatsBase,Distributions\nusing Plots,NamedColors ; theme(:default) #; plotlyjs()\nusing FFTW\n\nusing ProgressMeter\nusing Random\nRandom.seed!(0)\n\nusing HawkesSimulator; const global H = HawkesSimulator","category":"page"},{"location":"alphadelay/#Define-and-visualize-the-kernel","page":"1D Hawkes process with delayed alpha kernel","title":"Define and visualize the kernel","text":"","category":"section"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"mytau = 0.5\nmydelay = 2.0\nmyw = fill(0.85,(1,1)) # 1x1 matrix\nmyinput = [0.5,]       # 1-dim vector\n\nker = H.KernelAlphaDelay(mytau,mydelay)\n\nplt = let ts = range(-0.5,8;length=150)\n  y = [H.interaction_kernel(_t,ker) for _t in ts]\n  plt=plot(ts,y ; linewidth=3,leg=false,xlabel=\"time (s)\",\n      ylabel=\"interaction kernel\")\n  ymax=ylims()[2]\n  plot!(plt,[0,0],[0,ymax];linestyle=:dash,linecolor=:black)\nend;\nplot(plt)","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"Note that the kernel starts after zero, according to the delay indicated.","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"As a side note: in order to simulate Hawkes processes, one always needs to define a non-increasing upper limit to the kernel. This is what it looks like for this kernel.","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"plt = let  ts = range(-0.5,8;length=150)\n  y = [H.interaction_kernel(_t,ker) for _t in ts]\n  yu = [H.interaction_kernel_upper(_t,ker) for _t in ts]\n  plt = plot(ts,y ; linewidth=3,xlabel=\"time (s)\",\n      ylabel=\"interaction kernel\", label=\"true kernel\")\n  plot!(plt, ts,yu ; linewidth=2, label=\"upper limit\", linestyle=:dash)\n  ymax=ylims()[2]\n  plot!(plt,[0,0],[0,ymax];linestyle=:dash,linecolor=:black,label=\"\")\nend;\nplot(plt)","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"the closer the upper limit is to the true kernel, the more efficient the simulation.","category":"page"},{"location":"alphadelay/#Build-the-network-and-run-it","page":"1D Hawkes process with delayed alpha kernel","title":"Build the network and run it","text":"","category":"section"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"I compare the final rate with what I expect from the analytic solution (see first example file)","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"pops = H.PopulationState(ker,1)\nntw = H.RecurrentNetwork(pops,myw,myinput)\n\nfunction run_simulation!(network,num_spikes,\n    t_flush_trigger=300.0,t_flush=100.0)\n  t_now = 0.0\n  H.reset!(network) # clear spike trains etc\n  @showprogress \"Running Hawkes process...\" for _ in 1:num_spikes\n    t_now = H.dynamics_step_singlepopulation!(t_now,network)\n    H.flush_trains!(network,t_flush_trigger;Tflush=t_flush)\n  end\n  H.flush_trains!(network) # flush everything into history\n  return t_now\nend\n\nn_spikes = 80_000\nTmax = run_simulation!(ntw,n_spikes);\n\nratenum = H.numerical_rates(pops)[1]\nrate_analytic = (I-myw)\\myinput\nrate_analytic = rate_analytic[1] # from 1-dim vector to scalar\n\n@info \"Mean rate -  numerical $(round(ratenum;digits=2)), analytic  $(round(rate_analytic;digits=2))\"","category":"page"},{"location":"alphadelay/#Covariance-density","page":"1D Hawkes process with delayed alpha kernel","title":"Covariance density","text":"","category":"section"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"First, compute covariance density numerically for a reasonable time step","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"mytrain = pops.trains_history[1]\nmydt = 0.1\nmyτmax = 60.0\nmytaus = H.get_times(mydt,myτmax)\nntaus = length(mytaus)\ncov_times,cov_num = H.covariance_self_numerical(mytrain,mydt,myτmax);\nnothing #hide","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"now compute covariance density analytically (as in Hawkes models), at higher resolution, and compare analytic and numeric","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"Note that the high resolution is not just for a better plot, but also to ensure the result is more precise when we move from frequency domain (Fourier transforms) to time domain.","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"function four_high_res(dt::Real,Tmax::Real) # higher time resolution, longer time\n  k1,k2 = 2 , 0.01\n  myτmax = Tmax * k1\n  dt *= k2\n  mytaus = H.get_times(dt,myτmax)\n  nkeep = div(length(mytaus),k1)\n  myfreq = H.get_frequencies_centerzero(dt,myτmax)\n  gfou = myw[1,1] .* H.interaction_kernel_fourier.(myfreq,Ref(ker)) |> ifftshift\n  ffou = let r=rate_analytic\n    covf(g) = r/((1-g)*(1-g'))\n    map(covf,gfou)\n  end\n  retf = real.(ifft(ffou))\n  retf[2:end] ./= dt # first element is rate\n  return mytaus[1:nkeep],retf[1:nkeep]\nend\n\ntaush,covfou=four_high_res(mydt,myτmax)\n\ntheplot = let plt = plot(xlabel=\"time delay (s)\",ylabel=\"Covariance density\")\n  plot!(plt,cov_times[2:end], cov_num[2:end] ; linewidth=3, label=\"numerical\" )\n  plot!(plt,taush[2:end],covfou[2:end]; label=\"analytic\",linewidth=3,linestyle=:dash)\nend;\nplot(theplot)","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"Analytics and numerics match quite well, although not perfectly. Whatever.","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"THE END","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"This page was generated using Literate.jl.","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"EditURL = \"https://github.com/dylanfesta/HawkesSimulator.jl/blob/master/examples/plasticity_STDP.jl\"","category":"page"},{"location":"plasticity_STDP/#Spiking-based-plasticity-rules-for-two-neurons","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"","category":"section"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"In this example, I show the effects of plasticity rules on a single pre-post connection between the two neurons. The neural activity is entirely regulated from the outside (e.g. the neurons do not interact through their weights). This is to better illustrate plasticity rules in their simplest form.","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"I also consider analytic results for purely Poisson firing (uncorrelated).","category":"page"},{"location":"plasticity_STDP/#Initialization","page":"Spiking-based plasticity rules for two neurons","title":"Initialization","text":"","category":"section"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"using LinearAlgebra,Statistics,StatsBase,Distributions\nusing Plots,NamedColors,LaTeXStrings ; theme(:default) ; gr()\n\nusing InvertedIndices\nusing ProgressMeter\nusing Random\nRandom.seed!(0)\n\nusing HawkesSimulator; const global H = HawkesSimulator","category":"page"},{"location":"plasticity_STDP/#Part-1:-Poisson-processes","page":"Spiking-based plasticity rules for two neurons","title":"Part 1: Poisson processes","text":"","category":"section"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"Here the neurons are uncorrelated Poisson processes.","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"The goal is to emphasize the rate-dependent part of plasticity, comparing pairwise STDP to triplet STDP","category":"page"},{"location":"plasticity_STDP/#Plasticity:-positive-biased-STPD-rule","page":"Spiking-based plasticity rules for two neurons","title":"Plasticity: positive biased STPD rule","text":"","category":"section"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"Here the weight change will depent linearly on pre and post rate.","category":"page"},{"location":"plasticity_STDP/#Functions-that-generate-spiketrains,-plasticity,-population,-etc","page":"Spiking-based plasticity rules for two neurons","title":"Functions that generate spiketrains, plasticity, population, etc","text":"","category":"section"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"this one generates the connection object","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"function do_2by2_connection(τplus::R,A2plus::R,τminus::R,A2minus::R;w_start::R=100.0) where R\n  N=2\n  _plast = HawkesSimulator.PairSTDP(τplus,τminus,A2plus,A2minus,N,N)\n  W = fill(w_start,N,N)\n  W[diagind(W)] .= 0.0\n  return H.ConnectionWeights(W,_plast)\nend","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"this one generates spike trains, a network object, a weight recorder. It requres a connection","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"function population_trains(rate1::R,rate2::R,conn::H.Connection;\n    ttot::R=5_000.0,krec::Integer=400) where R\n  N = 2\n  trains =[ H.make_poisson_samples(rate1,ttot),\n             H.make_poisson_samples(rate2,ttot) ]\n  _ps = H.PopulationState(H.InputUnit(H.SGTrains(trains)),N)\n  pop = H.PopulationInputTestWeights(_ps,conn)\n  recweights = H.RecTheseWeights(conn.weights,ttot/krec,ttot)\n  ntw = H.RecurrentNetworkExpKernel(pop,recweights)\n  return recweights,ntw\nend","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"this put the previous two together","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"function plastic_two_neurons(τplus::R,A2plus::R,τminus::R,A2minus::R,rate1::R,rate2::R;\n    w_start::R=100.0,ttot::R=5_000.,krec=400) where R\n  conn = do_2by2_connection(τplus,A2plus,τminus,A2minus;w_start=w_start)\n  recweights,ntw = population_trains( rate1,rate2,conn; ttot=ttot,krec=krec)\n  return conn,recweights,ntw\nend","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"runs the network","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"function run_network01(ntw,conn,recweights,ttot)\n  H.reset!(ntw)\n  H.reset!(recweights)\n  w_start = copy(conn.weights)\n  _T=ttot-0.1\n  t_now = 0.0\n  prog = Progress(ceil(Integer,_T);dt=5)\n  while t_now <= _T\n    t_now = H.dynamics_step_singlepopulation!(t_now,ntw)\n    if t_now > _T\n      ProgressMeter.finish!(prog)\n    else\n      update!(prog,floor(Integer,t_now))\n    end\n  end\n  w_end = copy(conn.weights)\n  return w_start,w_end,t_now\nend","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"Utility functions to make nice plots","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"function mynormalize(mat::Matrix{<:Real})\n  _mi,_ma = extrema(mat)\n  hasminus = _mi < -1E-4\n  if hasminus\n    idxplus = mat .> 0\n    matnorm = similar(mat)\n    matnorm[idxplus] = mat[idxplus] ./ _ma\n    matnorm[Not(idxplus)] = mat[Not(idxplus)] ./ abs(_mi)\n  else\n    matnorm = mat ./ _ma\n  end\n  return hasminus,matnorm\nend\n\nfunction plot_nice_DW(r1::AbstractVector{R},r2::AbstractVector{R},DW::Matrix{R}) where R\n  rh = 0.5(r1[2]-r1[1])\n  colorh = colorant\"#F47D23\"\n  colorm = colorant\"white\"\n  colorl = colorant\"#147ABF\"\n  hasminus = minimum(DW) < -1E-2\n  if hasminus\n    myc = cgrad([colorl,colorm,colorh],[0,_mid,1.0])\n  else\n    myc = cgrad([colorm,colorh],[0,1.0])\n  end\n  _lims = (rh,rh+r1[end])\n  return heatmap(r1,r2,DW;\n    xlabel = L\"r_{\\mathrm{post}}\",\n    ylabel = L\"r_{\\mathrm{pre}}\",\n    xlims=_lims,ylims=_lims,\n    ratio=1, color=myc)\nend\nfunction plot_nice_DW_normed(r1::AbstractVector{R},r2::AbstractVector{R},DW::Matrix{R}) where R\n  colorh = colorant\"#F47D23\"\n  colorm = colorant\"white\"\n  colorl = colorant\"#147ABF\"\n  hasminus,DWn = mynormalize(DW)\n  if hasminus\n    myc = cgrad([colorl,colorm,colorh],[-1,0,1.0])\n  else\n    myc = cgrad([colorm,colorh],[0,1.0])\n  end\n  rh = 0.5(r1[2]-r1[1])\n  _lims = (rh,rh+r1[end])\n  return heatmap(r1,r2,DWn;\n    xlabel = L\"r_{\\mathrm{post}}\",\n    ylabel = L\"r_{\\mathrm{pre}}\",\n    xlims=_lims,ylims=_lims,\n    ratio=1,\n    color=myc)\nend","category":"page"},{"location":"plasticity_STDP/#Run-numerical-simulation-for-specific-parameters","page":"Spiking-based plasticity rules for two neurons","title":"Run numerical simulation for specific parameters","text":"","category":"section"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"# src\n\nconst plast_eps = 1E-4\nconst A2plus = 1.0 * plast_eps\nconst τplus = 0.5\nconst A2minus = -0.7 * plast_eps\nconst τminus = 0.69\nconst rate1 = 10.\nconst rate2 = 15.0\nconst ttot = 1_000.0","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"plot weight change in time","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"theplot = let  (conn,recweights,ntw) =\n    plastic_two_neurons(τplus,A2plus,τminus,A2minus,rate1,rate2;ttot=ttot),\n  (w_start,w_end,t_end) = run_network01(ntw,conn,recweights,ttot)\n  plt = plot(size=(300,200))\n  ws12 = [_w[1,2] for _w in recweights.weights]\n  ws21 = [_w[2,1] for _w in recweights.weights]\n  wtimes = recweights.times\n  plot!(plt,wtimes,ws12;label=L\"$w_{12}$\",linewidth=2)\n  plot!(plt,wtimes,ws21;label=L\"$w_{21}$\",linewidth=2)\n  plot!(plt,xlabel=\"time (s)\",ylabel=\"weight\",leg=:topleft,\n    title=\"\")\n  plt\nend\nplot(theplot)","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"The STDP rule is potentiation dominated, so the weights grow linearly.","category":"page"},{"location":"plasticity_STDP/#Run-numerical-simulation-for-varying-rates","page":"Spiking-based plasticity rules for two neurons","title":"Run numerical simulation for varying rates","text":"","category":"section"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"const nrates = 20\nconst rates1 = range(0.1,45.;length=nrates)\nconst rates2 = copy(rates1)\nconst DW12 = Matrix{Float64}(undef,nrates,nrates)\n\nconst plast_eps = 1E-4\nconst A2plus = 1.0 * plast_eps\nconst τplus = 0.5\nconst A2minus = -0.7 * plast_eps\nconst τminus = 0.69\nconst ttot = 1_000.0\n\n@showprogress for ij in CartesianIndices(DW12)\n  conn,recweights,ntw = plastic_two_neurons(τplus,A2plus,τminus,A2minus,\n    rates1[ij[1]],rates2[ij[2]];ttot=ttot)\n  (w_start,w_end,t_end) = run_network01(ntw,conn,recweights,ttot)\n  DW12[ij] = w_end[1,2] - w_start[1,2]\nend\n\nplot_nice_DW(rates1,rates2,DW12)","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"compare with analytic values","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"rates_an = range(0.1,45.;length=150)\nDW12_analytic_dense = let c = A2plus*τplus + A2minus*τminus\n  (c*ttot) .* (rates_an * rates_an')\nend\n\ntheplot = let  c = A2plus*τplus + A2minus*τminus\n  DW12_analytic = (c*ttot) .* (rates1 * rates2')\n  plt = plot()\n  scatter!(plt,DW12[:],DW12_analytic[:],color=:black)\n  plot!(plt,identity,ratio=1,xlabel=\"numeric\",ylabel=\"analytic\",linestyle=:dash,linewidth=3,\n    color=:yellow,leg=false)\nend","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"show the analytic heatmap","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"plot_nice_DW_normed(rates_an,rates_an,DW12_analytic_dense)","category":"page"},{"location":"plasticity_STDP/#Plasticity-:-triplet-STDP-with-usual-parameters","page":"Spiking-based plasticity rules for two neurons","title":"Plasticity : triplet STDP with usual parameters","text":"","category":"section"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"I will go straight to the part where I consider multiple rates","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"this one generates the connection object","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"function do_2by2_connection_triplets(τplus::R,A2plus::R,τminus::R,A2minus::R,\n     τx::R,A3plus::R,τy::R,A3minus::R;w_start::R=100.0) where R\n  N=2\n  _plast = HawkesSimulator.PlasticityTriplets(τplus,τminus,τx,τy,A2plus,A3plus,A2minus,A3minus,N,N)\n  W = fill(w_start,N,N)\n  W[diagind(W)] .= 0.0\n  return H.ConnectionWeights(W,_plast)\nend","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"this put the previous two together","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"function plastic_two_neurons_triplets(τplus::R,A2plus::R,τminus::R,A2minus::R,\n    τx::R,A3plus::R,τy::R,A3minus::R,rate1::R,rate2::R;\n    w_start::R=100.0,ttot::R=5_000.,krec=400) where R\n  conn = do_2by2_connection_triplets(τplus,A2plus,τminus,A2minus,τx,A3plus,τy,A3minus;w_start=w_start)\n  recweights,ntw = population_trains( rate1,rate2,conn; ttot=ttot,krec=krec)\n  return conn,recweights,ntw\nend\n\n\nconst nrates = 20\nconst rates1 = range(0.1,45.;length=nrates)\nconst rates2 = copy(rates1)\nconst DW12 = Matrix{Float64}(undef,nrates,nrates)","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"parameters considered as \"standard\" for triplet STDP rule","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"const plast_eps = 1E-3\n\nconst\tA2plus  = 7.5E-7 *plast_eps\nconst\tA2minus = -7.0   *plast_eps\nconst\tA3plus  = 6.0    *plast_eps  # 9.3\nconst\tA3minus = -0.23  *plast_eps\n\nconst τplus = 17E-3\nconst τminus = 34E-3\nconst τy = 101E-3\nconst τx = 125E-3","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"run simulation for varying rates","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"@showprogress for ij in CartesianIndices(DW12)\n  conn,recweights,ntw = plastic_two_neurons_triplets(τplus,A2plus,τminus,A2minus,\n    τx,A3plus,τy,A3minus,\n    rates1[ij[1]],rates2[ij[2]];ttot=ttot)\n  (w_start,w_end,t_end) = run_network01(ntw,conn,recweights,ttot)\n  DW12[ij] = w_end[1,2] - w_start[1,2]\nend","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"show result","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"plot_nice_DW(rates1,rates2,DW12)","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"compare with analytics","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"compare with analytic values","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"rates_dense = range(0.1,45.;length=150)\nDW12_analytic_dense = let r1r1 =  rates_dense * rates_dense'\n  r2r1 = (rates_dense.^2)*rates_dense'\n  r1r2 = rates_dense*(rates_dense.^2)'\n  c11 = A2plus*τplus + A2minus*τminus\n  c12 = A3minus*τminus*τx\n  c21 = A3plus*τplus*τy\n  @. ttot * (c11*r1r1 + c12*r1r2 + c21*r2r1)\nend\n\ntheplot = let r1r1 =  rates1 * rates2'\n  r2r1 = (rates1.^2)*rates2'\n  r1r2 = rates1*(rates2.^2)'\n  c11 = A2plus*τplus + A2minus*τminus\n  c12 = A3minus*τminus*τx\n  c21 = A3plus*τplus*τy\n  DW12_analytic =  @. ttot * (c11*r1r1 + c12*r1r2 + c21*r2r1)\n  plt = plot()\n  scatter!(plt,DW12[:],DW12_analytic[:],color=:black)\n  plot!(plt,identity,ratio=1,xlabel=\"numeric\",ylabel=\"analytic\",linestyle=:dash,linewidth=3,\n    color=:yellow,leg=false)\nend\nplot(theplot)","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"show the analytic heatmap","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"plot_nice_DW_normed(rates_an,rates_an,DW12_analytic_dense)","category":"page"},{"location":"plasticity_STDP/#Part-2-:-pairing-protocol","page":"Spiking-based plasticity rules for two neurons","title":"Part 2 : pairing protocol","text":"","category":"section"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"Here  neurons are forced to spike as in typical STDP experimental protocols. That is, they both fire at the same  rate, but with a time difference set to a certain Delta t.","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"function post_pre_spiketrains(rate::R,Δt_ro::R,Ttot::R;\n    tstart::R = 0.05) where R\n  post = collect(range(tstart,Ttot; step=inv(rate)))\n  pre = post .- Δt_ro\n  return [pre,post]\nend","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"let's take a look at one example: rate of 5.0 Hz, 20 ms difference in spike time","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"_ = let trains = post_pre_spiketrains(5.0,20E-3,1.0)\n  plt = plot()\n  scatter!(plt,trains[1], 0.1 .+ zero(trains[1]),markersize=30,\n      markercolor=:black,markershape=:vline,leg=false)\n  scatter!(plt,trains[2], 0.2 .+ zero(trains[2]),markersize=30,\n      markercolor=:black,markershape=:vline,leg=false)\n  plot!(plt,ylims=(0.0,0.3),xlims=(0,1),xlabel=\"time (s)\")\nend","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"Now I define a population of input neurons using this input protocol. The Population object includes the weight matrix and the plasticity rules associated to it, both wrapped in the Connection object. I consider the connection as an input parameter of this function, to be set externally with the desired plasticity rule.","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"Note that I define the population as PopulationInputTestWeights to indicate non-interacting weights","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"function post_pre_population(rate::Real,nreps::Integer,Δt_ro::Real,connection::H.Connection)\n  Ttot = nreps/rate\n  prepostspikes = post_pre_spiketrains(rate,Δt_ro,Ttot)\n  gen = H.SGTrains(prepostspikes)\n  state = H.PopulationState(H.InputUnit(gen),2)\n  return H.PopulationInputTestWeights(state,connection)\nend","category":"page"},{"location":"plasticity_STDP/#Constructors","page":"Spiking-based plasticity rules for two neurons","title":"Constructors","text":"","category":"section"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"Here I define a function that tests the plasticity rule. That is, given a Δt, it creates the input neurons, then it defines a network, and iterates it dynamically for a certain number of pre-post repetitions. Finally it outputs the weight total change divided by time (so it's a weight change per second)","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"Since both neurons have the same plasticity rule, a positive pre-post Delta t for neuron A, impacting the  w_textAB weight, is the equivalent of a negative pre-post Delta t for neuron B, impacting the w_textBA weight.","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"function test_stpd_rule(Δt::Real,connection::H.Connection;\n    nreps=510,wstart=100.0,rate=0.5)\n  num_spikes = nreps*2 - 10 # a bit less than total, for safety\n  recorder = H.RecFullTrain(num_spikes)\n  population = post_pre_population(rate,nreps,Δt,connection)\n  network = H.RecurrentNetworkExpKernel(population,recorder)\n  wmat = connection.weights\n  fill!(wmat,wstart)\n  wmat[diagind(wmat)] .= 0.0\n  t_now = 0.0\n  H.reset!.((network,recorder,connection)) # clear spike trains etc\n  for _ in 1:num_spikes\n    t_now = H.dynamics_step_singlepopulation!(t_now,network)\n  end\n  w12,w21 = wmat[1,2],wmat[2,1]\n  H.reset!(network)\n  dw12 = (w12-wstart)/t_now\n  dw21 = (w21-wstart)/t_now\n  return dw12,dw21\nend","category":"page"},{"location":"plasticity_STDP/#STDP-rule","page":"Spiking-based plasticity rules for two neurons","title":"STDP rule","text":"","category":"section"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"Here I define the plasticty type and the parameters that I want to test. I choose the pairwise STDP rule. I initialize the weight matrix to 100.0","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"Note once again that neurons are not interacting. The sole purpose of the \"dummy\" weights it to be changed by plasticity.","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"connection_test = let wmat =  fill(100.0,2,2)\n  wmat[diagind(wmat)] .= 0.0\n  τplus = 10E-3\n  τminus = 10E-3\n  Aplus = 1E-1\n  Aminus = -1E-1\n  npost,npre = size(wmat)\n  stdp_plasticity = H.PairSTDP(τplus,τminus,Aplus,Aminus,npost,npre)\n  H.ConnectionWeights(wmat,stdp_plasticity)\nend","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"let's do one run","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"dw12,dw21 = test_stpd_rule(2E-3,connection_test)\nprintln(\"change in w12 : $(dw12), change in w21 $(dw21)\")","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"Neuron 1 spikes before neuron 2, therefore connection from 1 to 2, dw21 is potentiated, while connection from 2 to 1, dw12 is depressed.","category":"page"},{"location":"plasticity_STDP/#STDP-curve","page":"Spiking-based plasticity rules for two neurons","title":"STDP curve","text":"","category":"section"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"Compute and plot the weight changes due to STDP for varying Delta ts","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"nsteps = 200\ndeltats = range(0.1E-3,100E-3;length=nsteps)\ndeltats_all = vcat(-reverse(deltats),deltats)\nout = Vector{Float64}(undef,2*nsteps)\n\nfor (i,Δt) in enumerate(deltats)\n  dw12,dw21 = test_stpd_rule(Δt,connection_test)\n  out[nsteps+i]=dw21\n  out[nsteps-i+1]=dw12\nend\n\n\nplot(deltats_all,out;leg=false,xlabel=\"Delta t\",ylabel=\"dw/dt\",linewidth=3)","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"THE END","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"This page was generated using Literate.jl.","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"EditURL = \"https://github.com/dylanfesta/HawkesSimulator.jl/blob/master/examples/exp_1and2D.jl\"","category":"page"},{"location":"exp_1and2D/#D-and-2D-Hawkes-processes-with-exponential-kernel","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"","category":"section"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"In this example, I simulate first a 1D self-exciting Hawkes process and then a 2D one. The interaction kernel is an exponentially decaying function, defined as:","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"g(t) = H(t)   frac1tau  expleft(- fracttau right)","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"where H(t) is the Heaviside function: zero for t0, one for tgeq 0.","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"Note that Kernels are always normalized so that their integral between -infty and +infty is 1.","category":"page"},{"location":"exp_1and2D/#Initialization","page":"1D and 2D Hawkes processes with exponential kernel","title":"Initialization","text":"","category":"section"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"using LinearAlgebra,Statistics,StatsBase,Distributions\nusing Plots,NamedColors ; theme(:default) ; gr()\nusing FFTW\n\nusing ProgressMeter\nusing Random\nRandom.seed!(0)\n\nusing HawkesSimulator; const global H = HawkesSimulator\n\n\"\"\"\n    onedmat(x::R) where R\nGenerates a 1-by-1 Matrix{R} that contains `x` as only element\n\"\"\"\nfunction onedmat(x::R) where R\n  return cat(x;dims=2)\nend;\nnothing #hide","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"First I define the kernel, and the self-interaction weight.","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"myw is a scaling factor (the weight of the autaptic connection). The baseline rate is given by myinput","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"mytau = 0.5  # kernel time constant\nmyw = onedmat(0.85) # weight: this needs to be a matrix\nmyinput = [0.7,] # this needs to be a vector\nmykernel = H.KernelExp(mytau);\nnothing #hide","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"This is the plot of the (self) interaction kernel (before  the scaling by myw)","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"theplot = let ts = range(-1.0,5;length=150),\n  y = map(t->H.interaction_kernel(t,mykernel) , ts )\n  plot(ts , y ; linewidth=3,leg=false,xlabel=\"time (s)\",\n    color = :black,\n     ylabel=\"interaction kernel\")\nend;\nplot(theplot)","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"Now I build the network, using the simplified constructor for one-population networks. The object PopulationState initializes a population of Hawkes neurons of the specified size (1, in this case) and the kernel mykernel neurons in the same population all have the same kernel. (this might be an inconvenience if one wants qualitatively different self-connections... but it might be fixed in future versions)","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"popstate = H.PopulationState(mykernel,1)\nntw = H.RecurrentNetwork(popstate,myw,myinput);\nnothing #hide","category":"page"},{"location":"exp_1and2D/#Simulation","page":"1D and 2D Hawkes processes with exponential kernel","title":"Simulation","text":"","category":"section"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"The length of the simulation is measured by the total number of spikes here called num_spikes. The function flush_trains!(...) is used to store older spikes as history and let them be ignored by the kernels. The time parameters should be regulated based on the kernel shape.","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"function run_simulation!(network,num_spikes,\n    t_flush_trigger=300.0,t_flush=100.0)\n  t_now = 0.0\n  H.reset!(network) # clear spike trains etc\n  @showprogress \"Running Hawkes process...\" for _ in 1:num_spikes\n    t_now = H.dynamics_step_singlepopulation!(t_now,network)\n    H.flush_trains!(network,t_flush_trigger;Tflush=t_flush)\n  end\n  H.flush_trains!(network) # flush everything into history\n  return t_now\nend\n\nn_spikes = 100_000\nTmax = run_simulation!(ntw,n_spikes)\nratenum = H.numerical_rates(popstate;Tend=Tmax)[1]\n@info \"Simulation completed, mean rate $(round(ratenum;digits=2)) Hz\"\n\n#","category":"page"},{"location":"exp_1and2D/#Visualize-raster-plot-of-the-events","page":"1D and 2D Hawkes processes with exponential kernel","title":"Visualize raster plot of the events","text":"","category":"section"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"the raster plot shows some correlation between the neural activities neuron one (lower row) excites neuron two (upper row)","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"function rasterplot(tlims = (1100.,1120.) )\n  _train = popstate.trains_history[1]\n  plt=plot()\n  train = filter(t-> tlims[1]< t < tlims[2],_train)\n  nspk = length(train)\n  scatter!(plt,train,fill(0.1,nspk),markersize=30,\n      markercolor=:black,markershape=:vline,leg=false)\n  return plot!(plt,ylims=(0.0,0.2),xlabel=\"time (s)\")\nend\n\nrasterplot()","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"event times are always stored in pops.trains_history","category":"page"},{"location":"exp_1and2D/#Plot-the-instantaneous-rate","page":"1D and 2D Hawkes processes with exponential kernel","title":"Plot the instantaneous rate","text":"","category":"section"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"This is the probability of a spike given the past activity up until that moment. It is usually denoted by lambda^*(t).","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"function get_insta_rate(t,popstate)\n  _train = popstate.trains_history[1]\n  myinput[1] + H.interaction(t,_train,myw[1],popstate.unittype)\nend\nfunction plot_instarate(popstate,tlims=(1100,1120))\n  tplot = range(tlims...;length=100)\n  _train = popstate.trains_history[1]\n  tspk = filter(t-> tlims[1]<=t<=tlims[2],_train) # add the exact spiketimes for cleaner plot\n  tplot = sort(vcat(tplot,tspk,tspk .- 1E-4))\n  plt=plot(xlabel=\"time (s)\",ylabel=\"instantaneous rate\")\n  plot!(plt,t->get_insta_rate(t,popstate),tplot;linewidth=2,color=:black)\n  scatter!(t->get_insta_rate(t,popstate),tspk;leg=false)\n  avg_rate = H.numerical_rates(popstate;Tend=Tmax)[1]\n  ylim2 = ylims()[2]\n  plot!(plt,tplot, fill(avg_rate,length(tplot)),\n     color=:red,linestyle=:dash,ylims=(0,ylim2))\nend\nplot_instarate(popstate)","category":"page"},{"location":"exp_1and2D/#Plot-the-total-event-counts","page":"1D and 2D Hawkes processes with exponential kernel","title":"Plot the total event counts","text":"","category":"section"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"Total number of events as a function of time. It grows linearly, and the steepness is pretty much the rate.","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"function plot_counts(tlims=(0.,1000.))\n  avg_rate = H.numerical_rates(popstate;Tend=Tmax)[1]\n  tplot = range(tlims...;length=100)\n  _train = popstate.trains_history[1]\n  nevents(tnow::Real) = count(t-> t <= tnow,_train)\n  plt=plot(xlabel=\"time (s)\",ylabel=\"number of events\",leg=false)\n  plot!(plt,tplot,nevents.(tplot),color=:black,linewidth=2)\n  plot!(plt,tplot , tplot .* avg_rate,color=:red,linestyle=:dash)\nend\nplot_counts()","category":"page"},{"location":"exp_1and2D/#Rate","page":"1D and 2D Hawkes processes with exponential kernel","title":"Rate","text":"","category":"section"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"Now I compare the numerical rate with the analytic solution.","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"The analytic rate corresponds to the stationary solution of a linear dynamical system (assumung all stationary rates are above zero).","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"fracmathrm d mathbf rmathrm d t = - mathbf r + Wr + mathbf h quad\nqquad  r_infty = (I-W)^-1  mathbf h","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"rate_analytic = inv(I-myw)*myinput\nrate_analytic = rate_analytic[1] # 1-D , just a scalar\n\n@info \"Mean rate -  numerical $(round(ratenum;digits=2)), analytic  $(round(rate_analytic;digits=2))\"","category":"page"},{"location":"exp_1and2D/#Covariance-density","page":"1D and 2D Hawkes processes with exponential kernel","title":"Covariance density","text":"","category":"section"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"Definition:","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"C(tau) = left left( S(t) - r right) left( S(t-tau) - r right) right_t","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"Where r is the mean rate, and S(t) is the spike train.","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"Here I compute it numerically.","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"mytrain = popstate.trains_history[1]\nmydt = 0.1\nmyτmax = 25.0\nmytaus = H.get_times(mydt,myτmax)\nntaus = length(mytaus)\ncov_times,cov_num = H.covariance_self_numerical(mytrain,mydt,myτmax);\nnothing #hide","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"Now I compute the covariance density analytically, at higher resolution, and I compare the two.","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"function four_high_res(dt::Real,Tmax::Real) # higher time resolution, longer time\n  k1,k2 = 2 , 0.01\n  myτmax = Tmax * k1\n  dt *= k2\n  mytaus = H.get_times(dt,myτmax)\n  nkeep = div(length(mytaus),k1)\n  myfreq = H.get_frequencies_centerzero(dt,myτmax)\n  gfou = myw[1,1] .* H.interaction_kernel_fourier.(myfreq,Ref(popstate)) |> ifftshift\n  ffou = let r=rate_analytic\n    covf(g) = r/((1-g)*(1-g'))\n    map(covf,gfou)\n  end\n  retf = real.(ifft(ffou)) ./ dt\n  retf[1] *= dt  # first element is rate\n  return mytaus[1:nkeep],retf[1:nkeep]\nend\n\n(taush,covfou)=four_high_res(mydt,myτmax)\n\ntheplot =  let  plt = plot(xlabel=\"time delay (s)\",ylabel=\"Covariance density\")\n  plot!(plt,cov_times[2:end], cov_num[2:end] ; linewidth=3, label=\"simulation\" )\n  plot!(plt,taush[2:end],covfou[2:end]; label=\"analytic\",linewidth=3,linestyle=:dash)\n  plt\nend;\nplot(theplot)","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"1D system completed !","category":"page"},{"location":"exp_1and2D/#D-Hawkes-process,-same-stuff","page":"1D and 2D Hawkes processes with exponential kernel","title":"2D Hawkes process, same stuff","text":"","category":"section"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"myτ = 1/2.33\nmywmat = [ 0.31   0.3\n           0.9  0.15 ]\nmyin = [1.0,0.1]\np1 = H.KernelExp(myτ)\nps1 = H.PopulationState(p1,2)\nntw = H.RecurrentNetwork(ps1,mywmat,myin);\nnothing #hide","category":"page"},{"location":"exp_1and2D/#Start-the-simulation","page":"1D and 2D Hawkes processes with exponential kernel","title":"Start the simulation","text":"","category":"section"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"the function run_simulation!(...) has been defined above Note that n_spikes is the total number of spikes among all units in the system.","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"n_spikes = 500_000\n\nTmax = run_simulation!(ntw,n_spikes,100.0,10.0);\nnothing #hide","category":"page"},{"location":"exp_1and2D/#Rates:-numeric-Vs-analytic","page":"1D and 2D Hawkes processes with exponential kernel","title":"Rates: numeric Vs analytic","text":"","category":"section"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"The analytic rate is from  Eq between 6 and  7 in Hawkes 1971","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"num_rates = H.numerical_rates(ps1)\nmyspikes_both = ps1.trains_history\n\nratefou = let G0 =  mywmat .* H.interaction_kernel_fourier(0,p1)\n  inv(I-G0)*myin |> real\nend\nrate_analytic = inv(I-mywmat)*myin\n\n@info \"Total duration $(round(Tmax;digits=1)) s\"\n@info \"Rates are $(round.(num_rates;digits=2))\"\n@info \"Analytic rates are $(round.(rate_analytic;digits=2)) Hz\"","category":"page"},{"location":"exp_1and2D/#Covariance-density-2","page":"1D and 2D Hawkes processes with exponential kernel","title":"Covariance density","text":"","category":"section"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"there are 4 combinations, therefore I will compare 4 lines.","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"mydt = 0.1\nmyτmax = 15.0\nmytaus = H.get_times(mydt,myτmax)\nntaus = length(mytaus)\ncov_times,cov_num = H.covariance_density_numerical(myspikes_both,mydt,myτmax)\n\ntheplot = let  plt=plot(xlabel=\"time delay (s)\",ylabel=\"Covariance density\")\n  for i in 1:2, j in 1:2\n    plot!(plt,cov_times[2:end-1],cov_num[2:end-1,i,j], linewidth = 3, label=\"cov $i-$j\")\n  end\n  plt\nend;\nplot(theplot)","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"The analytic solution is eq 12 from Hawkes 1971","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"function four_high_res(dt::Real,Tmax::Real)\n  k1 = 2\n  k2 = 0.005\n  myτmax,mydt = Tmax * k1, dt*k2\n  mytaus = H.get_times(mydt,myτmax)\n  nkeep = div(length(mytaus),k1)\n  myfreq = H.get_frequencies_centerzero(mydt,myτmax)\n  G_omega = map(mywmat) do w\n    ifftshift( w .* H.interaction_kernel_fourier.(myfreq,Ref(p1)))\n  end\n  D = Diagonal(ratefou)\n  M = Array{ComplexF64}(undef,length(myfreq),2,2)\n  Mt = similar(M,Float64)\n  for k in eachindex(myfreq)\n    G = getindex.(G_omega,k)\n    M[k,:,:] = (I-G)\\D/(I-G')\n  end\n  for i in 1:2,j in 1:2\n    Mt[:,i,j] = real.(ifft(M[:,i,j]))\n    Mt[2:end,i,j] ./= mydt # diagonal of t=0 contains the rate\n  end\n  return mytaus[1:nkeep],Mt[1:nkeep,:,:]\nend\n\ntaush,Cfou=four_high_res(mydt,myτmax)\n\nfunction oneplot(i,j)\n  plt=plot(xlabel=\"time delay (s)\",ylabel=\"Covariance density\",title=\"cov $i - $j\")\n  plot!(plt,mytaus[2:end],cov_num[2:end,i,j] ; linewidth = 3, label=\"simulation\")\n  plot!(plt,taush[2:end],Cfou[2:end,i,j]; linestyle=:dash, linewidth=3, label=\"analytic\")\nend","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"1","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"oneplot(1,1)","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"2","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"oneplot(1,2)","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"3","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"oneplot(2,1)","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"4","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"oneplot(2,2)","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"THE END","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = HawkesSimulator","category":"page"},{"location":"#Hawkes-Processes-Simulator","page":"Home","title":"Hawkes Processes Simulator","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nThe documentation is still missing. Please see the \"examples\" section for usage.","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simple case: 1D and 2D with exponential kernel\n1D Hawkes process with a delayed kernel\nShow that rate in Hawkes is equivalent to linear network, in a 2D model\nPlasticity, pairwise STDP and triplet-based","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [HawkesSimulator]","category":"page"},{"location":"#HawkesSimulator.bin_spikes-Union{Tuple{R}, Tuple{Vector{R}, R, R}} where R","page":"Home","title":"HawkesSimulator.bin_spikes","text":"bin_spikes(Y::Vector{R},dt::R,Tend::R;Tstart::R=0.0) where R\n\nArguments\n\nY::Vector{<:Real} : vector of spike times\ndt::Real : time bin size\nTend::Real : end time for the raster\n\nOptional argument\n\nTstart::Real=0.0 : start time for the raster\n\nReturns\n\nbinned_spikes::Vector{<:Integer} : binned_spikes[k] is the number of spikes that occur    in the timebin k  (i.e. between Tstart + (k-1)*dt and Tstart + k*dt)\n\n\n\n\n\n","category":"method"},{"location":"#HawkesSimulator.draw_spike_raster-Union{Tuple{C}, Tuple{Vector{Vector{Float64}}, Real, Real}} where C<:ColorTypes.Color","page":"Home","title":"HawkesSimulator.draw_spike_raster","text":"drawspikeraster(trains::Vector{Vector{Float64}},       dt::Real,Tend::Real;       Tstart::Real=0.0,       spikesize::Integer = 5,       spikeseparator::Integer = 1,       backgroundcolor::Color=RGB(1.,1.,1.),       spikecolors::Union{C,Vector{C}}=RGB(0.,0.0,0.0),       max_size::Real=1E4) where C<:Color\n\nDraws a matrix that contains the raster plot of the spike train.\n\nArguments\n\nTrains :  Vector of spike trains. The order of the vector corresponds to  the order of the plot. First element is at the top, second is second row, etc.\ndt : time interval representing one horizontal pixel  \nTend : final time to be considered\n\nOptional arguments\n\nTstart::Real : starting time\nspike_size::Integer : heigh of spike (in pixels)\nspike_separator::Integer : space between spikes, and vertical padding\nbackground_color::Color : self-explanatory\nspike_colors::Union{Color,Vector{Color}} : if a single color, color of all spikes, if vector of colors,   color for each neuron (length should be same as number of neurons)\nmax_size::Integer : throws an error if image is larger than this number (in pixels)\n\nReturns\n\nraster_matrix::Matrix{Color} you can save it as a png file\n\n\n\n\n\n","category":"method"},{"location":"#HawkesSimulator.dynamics_step_singlepopulation!-Tuple{Real, HawkesSimulator.RecurrentNetwork}","page":"Home","title":"HawkesSimulator.dynamics_step_singlepopulation!","text":"dynamics_step_singlepopulation!(t_now::Real,ntw::RecurrentNetwork)\n\nIterates a one-population network up until its next spike time. This is done by computing a next spike proposal for each neuron, and then picking the one that happens sooner. This spike is then added to the  spiketrain for that neuron. The fundtion returns the new current time of the simulation.\n\nFor long simulations, this functions should be called jointly with  flush_trains!. Otherwise the spike trains will keep growing, making the  propagation of signals extremely cumbersome.\n\nArguments\n\nt_now - Current time of the simulation\nntw   - The network\n\nReturns\n\nt_now_new - the new current time of the simulation\n\n\n\n\n\n","category":"method"},{"location":"#HawkesSimulator.flush_trains!-Tuple{HawkesSimulator.PopulationState, Real}","page":"Home","title":"HawkesSimulator.flush_trains!","text":"flush_trains!(ps::PopulationState,Ttrigger::Real;\n    Tflush::Union{Real,Nothing}=nothing)\n\nSpike history is spiketimes that do not interact with the kernel (because too old)         This function compares most recent spike with spike history, if enough time has passed   (measured by Ttrigger) it flushes the spiketrain up to Tflush into the history.\n\n\n\n\n\n","category":"method"},{"location":"#HawkesSimulator.warmup_step!-Tuple{Real, HawkesSimulator.RecurrentNetwork, Union{Vector{Vector{Float64}}, Vector{Float64}}}","page":"Home","title":"HawkesSimulator.warmup_step!","text":"warmupstep!(tnow::Real,ntw::RecurrentNetwork,     warmuprates::Union{Vector{Float64},Vector{Vector{Float64}}}) -> tend\n\nIn the warmup phase, all neurons fire as independent Poisson process  with a rate set by warmup_rates.   This is useful to quick-start the network, or set itinitial conditions that are far from the stable point.\n\nArguments\n\nt_now - current time\nntw  - the network (warning: weights and kernels are entirely ignored here)\nwarmup_rates - the desired stationary rates. In a one-population network,   it is a vector with the desired rates. In a multi-population network,   is a collection of vectors, where each vector refers to one population.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"TODO : add other  file. [comment]: <> ( 1. 2D delayed-alpha interactions, and non-delayed autapses 1. 1D delayed-alpha kernel 1. Plasticity examples, with pairwise STPD and triplets )","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"EditURL = \"https://github.com/dylanfesta/HawkesSimulator.jl/blob/master/examples/hawkes_vs_2D_linear.jl\"","category":"page"},{"location":"hawkes_vs_2D_linear/#Compares-a-2D-Hawekes-process-to-a-2D-linear-system","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"","category":"section"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"In this example, I show that the mean rates in a 2D Hawes process perfectly match the mean rates of a 2D rate model.","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"I use exponential synaptic kernels (but it is valid for any kernel, since the kernel shape does not influence the mean rate)","category":"page"},{"location":"hawkes_vs_2D_linear/#Initialization","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Initialization","text":"","category":"section"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"using LinearAlgebra,Statistics,StatsBase,Distributions\nusing Plots,NamedColors ; theme(:default)\nusing FFTW\n\nusing ProgressMeter\nusing Random\nRandom.seed!(0)\n\nusing HawkesSimulator; const global H = HawkesSimulator\n\nfunction onedmat(x::Real)\n  return cat(x;dims=2)\nend;\nnothing #hide","category":"page"},{"location":"hawkes_vs_2D_linear/#Rate-Model","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Rate Model","text":"","category":"section"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"function iofunction(v::R,_v0::R,_α::R) where R<:Real\n  return max(_α*(v-_v0),zero(R))\nend\nfunction iofunction_inv(r::R,_v0::R,_α::R) where R<:Real\n  return max(zero(R),r/_α+_v0)\nend\n\nconst v0 = -70.0 # -70\nconst α = 0.03 # 0.3\nconst taus = [20.0, 10.0].*1E-3\nconst weights = [1.25 -0.65 ; 1.2 -0.5]\nconst input = [20.0, 50.0]\nconst dt = 0.01E-3\nconst Ttot = 1.0\nconst taus_hawk = [3.0,3.0];\nnothing #hide","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"Let's plot the activation function","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"theplot = let vs = range(-90,50.,length=150)\n  rs = @. iofunction(vs,v0,α)\n  plot(vs,rs;linewidth=2,leg=false,xlabel=\"voltage (mV)\",ylabel=\"rate (Hz)\",color=:black)\nend;\nplot(theplot)","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"I run the rate model by Euler integration, with timesteps of 0.01 ms (the variable dt)","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"function euler_dv(v::Vector{R},_weights::Matrix{R},_input::Vector{R},\n    _taus::Vector{R},_v0::R,_α::R) where R<:Real\n  r = @. iofunction(v,_v0,_α)\n  return (.-v .+ (_weights*r) .+ _input) ./ _taus\nend\n\nfunction run_2D_network()\n  v_start_e,v_start_i = 0.0,0.0\n  times = range(0.0,Ttot;step=dt)\n  ntimes = length(times)\n  rates = Matrix{Float64}(undef,2,ntimes)\n  v = [v_start_e,v_start_i]\n  for tt in eachindex(times)\n    rates[:,tt] = iofunction.(v,v0,α)\n    dv = euler_dv(v,weights,input,taus,v0,α)\n    v += dv*dt\n  end\n  return times,rates\nend;\n\n\nruntimes,runrates = run_2D_network();\nnothing #hide","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"rates and times have been stored in the variables above!","category":"page"},{"location":"hawkes_vs_2D_linear/#Hawkes-process","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Hawkes process","text":"","category":"section"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"To define the Hawkes process, I need to find equivalent rates and currents that account for the input-output function that I used.","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"weights_equiv = @. abs(α^2*weights)\ninputs_equiv =  α .* (input .- (α .* weights+I)*fill(v0,2))\nps_e,tr_e = H.population_state_exp_and_trace(1,taus_hawk[1])\nps_i,tr_i = H.population_state_exp_and_trace_inhibitory(1,taus_hawk[2])","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"define conenctions","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"conn_ee = H.ConnectionExpKernel(onedmat(weights_equiv[1,1]),tr_e)\nconn_ie = H.ConnectionExpKernel(onedmat(weights_equiv[2,1]),tr_e)\nconn_ei = H.ConnectionExpKernel(onedmat(weights_equiv[1,2]),tr_i)\nconn_ii = H.ConnectionExpKernel(onedmat(weights_equiv[2,2]),tr_i);\nnothing #hide","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"define populations","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"pop_e = H.PopulationExpKernel(ps_e,inputs_equiv[1:1],(conn_ee,ps_e),(conn_ei,ps_i) )\npop_i = H.PopulationExpKernel(ps_i,inputs_equiv[2:2],(conn_ie,ps_e),(conn_ii,ps_i) );\nnothing #hide","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"define recorder: I record all spiketimes, although I only need the rate","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"nrec = 10_010\nrec = H.RecFullTrain(nrec,2);\nnothing #hide","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"define network:","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"netw = H.RecurrentNetworkExpKernel((pop_e,pop_i),(rec,));\nnothing #hide","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"run network","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"function run_simulation!(network,num_spikes)\n  t_now = 0.0\n  H.reset!(network) # clear spike trains etc\n  for _ in 1:num_spikes\n    t_now = H.dynamics_step!(t_now,network)\n  end\n  return t_now\nend\n\nnspikes = nrec - 1\nt_end=run_simulation!(netw,nspikes)\n\n# #src\n\nrates_e,rates_i = H.numerical_rates(rec);\nnothing #hide","category":"page"},{"location":"hawkes_vs_2D_linear/#Result:-compare-the-rate-in-the-two-sytems","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Result: compare the rate in the two sytems","text":"","category":"section"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"@info \"final rates are $(runrates[:,end])\"\n@info \"Hawkes final rates are $(first.((rates_e,rates_i)))\"","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"THE END","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"This page was generated using Literate.jl.","category":"page"}]
}
