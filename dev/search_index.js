var documenterSearchIndex = {"docs":
[{"location":"plasticity_rate_based/#Rate-based-plasticity-rules","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"","category":"section"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"Here I use the rate-dependent STPD rules for some simple examples.","category":"page"},{"location":"plasticity_rate_based/#Initialization","page":"Rate-based plasticity rules","title":"Initialization","text":"","category":"section"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"using LinearAlgebra,Statistics,StatsBase,Distributions\nusing Plots,NamedColors,LaTeXStrings ; theme(:default) ; gr()\n\nusing InvertedIndices\nusing ProgressMeter\nusing Random\nRandom.seed!(0)\n\nusing HawkesSimulator; const global H = HawkesSimulator","category":"page"},{"location":"plasticity_rate_based/#Utility-functions","page":"Rate-based plasticity rules","title":"Utility functions","text":"","category":"section"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"function do_colormap(minval::Real,maxval::Real;\n     cminus=:red,czero=:white,cplus=:blue,\n     ncolors::Integer=500)\n  if minval >= 0\n    return cgrad([czero,cplus], [0,1])\n  end\n  if maxval <= 0\n    return cgrad([cminus,czero], [0,1])\n  end\n  _mid = minval/(minval-maxval)\n  vcols = [cminus,fill(czero,ncolors-2)...,cplus]\n  midrange = range(_mid-1E-10,_mid+1E-10,length=ncolors-2)\n  vals = [0.,midrange...,1.]\n  return cgrad(vcols,vals)\nend\n\nfunction Wplot(W::Matrix{<:Real},bounds::Tuple{<:Real,<:Real}=extrema(W);\n    title::String=\"\")\n  N=size(W,1)\n  _cmap = do_colormap(bounds...)\n  return heatmap(W;ratio=1,\n    xlims=(0,N).+0.5,\n    ylims=(0,N).+0.5,\n    xlabel = \"pre\",\n    ylabel = \"post\",\n    color=_cmap,\n    clims=bounds,\n    title=title)\nend;\nnothing #hide","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"function to run the siumulation","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"function run_simulation!(network,n_spikes;show_progress=false,t_start::Float64=0.0)\n  t_now = t_start\n  pr = Progress(n_spikes;\n    enabled=show_progress,dt=30.0,desc=\"Running network dynamics...\")\n  for _ in 1:n_spikes\n    t_now = H.dynamics_step!(t_now,network)\n    ProgressMeter.next!(pr)\n  end\n  ProgressMeter.finish!(pr)\n  return t_now\nend;\nnothing #hide","category":"page"},{"location":"plasticity_rate_based/#First-example:-E-E-network-with-symmetric-rule-in-\"tuning\"-plasticty-regime","page":"Rate-based plasticity rules","title":"First example: E E network with symmetric rule in \"tuning\" plasticty regime","text":"","category":"section"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"n_spikes = 6_000_000\nτker_e = 50E-3\nne = 10\nhe = 10.0\nwmin = 1E-5\n\nps_e,tr_e = H.population_state_exp_and_trace(ne,τker_e);\nnothing #hide","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"E to E plasticity is created here. the tuning feature is regulated by setting θ clearly lower than -1","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"plasticity_ee_nonblanket = let A = 8E-7,\n  ree_targ = 11.0,\n  τ = 40E-3,\n  wee_max = 0.1, # will never be reached, as long as the target rate is low enough\n  γ = 10.0,\n  θ = -1.1, #  must be lower than -1 !\n  αpre =  -ree_targ*(1+θ)\n  αpost = -ree_targ*(1+θ)\n  bounds=H.PlasticityBoundsLowHigh(wmin,wee_max)\n  H.PlasticitySymmetricSTDPX(A,θ,τ,γ,αpre,αpost,ne,ne;\n      plasticity_bounds=bounds)\nend;\nnothing #hide","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"generate initial weights","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"W_start = fill(0.01,ne,ne)\nW_start[diagind(W_start)] .= 0.0\n\nconnection_ee = H.ConnectionExpKernel(copy(W_start),tr_e,plasticity_ee_nonblanket);\nnothing #hide","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"define populations","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"pop_e = H.PopulationExpKernel(ps_e,fill(he,ne),(connection_ee,ps_e));\nnothing #hide","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"Record all spikes for a single population","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"rec_spk = H.RecFullTrain(n_spikes+1,1);\nnothing #hide","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"Record weights too","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"Δt_wrec = 5*60.0\nTend_wrec =  14*3600.0\nrec_wee = H.RecTheseWeights(connection_ee.weights,Δt_wrec,Tend_wrec);\nnothing #hide","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"define network:","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"netw = H.RecurrentNetworkExpKernel((pop_e,),(rec_spk,rec_wee));\nnothing #hide","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"Ready to run!","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"H.reset!(netw)\nt_end = run_simulation!(netw,n_spikes;show_progress=false)\n@info \"\"\"\nSimulation completed at time $(round(t_end/60.0;digits=1)) min or $(round(t_end/3600.0;digits=2)) hours\n\"\"\"\n\n\nW_end = connection_ee.weights;\nnothing #hide","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"get weights","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"rec_weec = H.get_content(rec_wee)\ntimes_W = rec_weec.times\nWs = rec_weec.weights;\nnothing #hide","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"get spikes","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"recc_spk = H.get_content(rec_spk)\ntrains_e = H.get_trains(recc_spk;pop_idx=1)\n\nΔt_rates = 10*60.0\ntimes_r, rates_insta_e = H.instantaneous_rates(trains_e,Δt_rates ,t_end);\nnothing #hide","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"plot the rates to show that they are more or less stable","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"plot(times_r ./ 60.0,rates_insta_e';\n  label=\"rates\",xlabel=\"time (min)\",ylabel=\"rate (Hz)\",linewidth=2,leg=false,\n  linecolor=:blue,opacity=0.5,\n  ylims=(0,maximum(rates_insta_e)*1.1))","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"plot the average weight, to check for stability","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"theplot = let yplot = mean.(Ws)\n  plot(times_W ./ 60.0,yplot;\n    label=\"average weight\",xlabel=\"time (min)\",ylabel=\"weight\",linewidth=5,leg=false,\n    linecolor=colorant\"orange\",opacity=0.5,\n    ylims=(0,maximum(yplot)*1.1 ))\nend","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"plot the weight matrix before","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"p1 = Wplot(W_start;title=\"initial weights\")","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"plot weight after","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"p2 = Wplot(W_end;title=\"final weights\")","category":"page"},{"location":"plasticity_rate_based/#Result","page":"Rate-based plasticity rules","title":"Result","text":"","category":"section"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"Even without heterosynaptic effects, then netwrok reaches a symmetric sparse structre. The number of connections depends on the target rate.","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"But careful! When neuron correlate, they increase their target rate, therefore the final rate will not correspond to the target rate, but be higher! So a high target rate might result in an even higher final rate, with the risk of triggering a runaway excitation.","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"In this regime, seems that the target rate should be very close to the input current. So this type of plasticity can't be used to change the network operating regine.","category":"page"},{"location":"plasticity_rate_based/#Blanket-exc-to-exc","page":"Rate-based plasticity rules","title":"Blanket exc to exc","text":"","category":"section"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"We want something really rate-dominated. Therefore the (1+θ) should be strong and negative.  Hence θ = -4.0","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"he = 5.0\nplasticity_ee_blanket = let A = 8E-7,\n  ree_targ = 30.0,\n  τ = 40E-3,\n  wee_max = Inf, # here does not play a role!\n  γ = 10.0,\n  θ = -4.0, #  must be lower than -1 !\n  αpre =  -ree_targ*(1+θ)\n  αpost = -ree_targ*(1+θ)\n  bounds=H.PlasticityBoundsLowHigh(wmin,wee_max)\n  H.PlasticitySymmetricSTDPX(A,θ,τ,γ,αpre,αpost,ne,ne;\n      plasticity_bounds=bounds)\nend;\nnothing #hide","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"generate initial weights","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"W_start = fill(0.01,ne,ne)\nW_start[diagind(W_start)] .= 0.0\n\n\nH.reset!(ps_e)\nconnection_ee = H.ConnectionExpKernel(copy(W_start),tr_e,plasticity_ee_blanket);\nnothing #hide","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"define populations","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"pop_e = H.PopulationExpKernel(ps_e,fill(he,ne),(connection_ee,ps_e));\nnothing #hide","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"Record all spikes for a single population","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"rec_spk = H.RecFullTrain(n_spikes+1,1)","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"Record weights too","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"rec_wee = H.RecTheseWeights(connection_ee.weights,Δt_wrec,Tend_wrec)","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"define network:","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"netw = H.RecurrentNetworkExpKernel((pop_e,),(rec_spk,rec_wee));\nnothing #hide","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"Ready to run!","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"t_end = run_simulation!(netw,n_spikes;show_progress=false)\n@info \"\"\"\nSimulation completed at time $(round(t_end/60.0;digits=1)) min or $(round(t_end/3600.0;digits=2)) hours\n\"\"\"\n\n\nW_end = connection_ee.weights;\nnothing #hide","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"get weights","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"rec_weec = H.get_content(rec_wee)\ntimes_W = rec_weec.times\nWs = rec_weec.weights;\nnothing #hide","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"get spikes","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"recc_spk = H.get_content(rec_spk)\ntrains_e = H.get_trains(recc_spk;pop_idx=1)\n\ntimes_r, rates_insta_e = H.instantaneous_rates(trains_e,Δt_rates ,t_end);\nnothing #hide","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"plot the rates to show that they are more or less stable","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"plot(times_r ./ 60.0,rates_insta_e';\n  label=\"rates\",xlabel=\"time (min)\",ylabel=\"rate (Hz)\",linewidth=2,leg=false,\n  linecolor=:blue,opacity=0.5,\n  ylims=(0,maximum(rates_insta_e)*1.1))","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"plot the average weight, to check for stability","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"theplot = let yplot = mean.(Ws)\n  plot(times_W ./ 60.0,yplot;\n    label=\"average weight\",xlabel=\"time (min)\",ylabel=\"weight\",linewidth=5,leg=false,\n    linecolor=colorant\"orange\",opacity=0.5,\n    ylims=(0,maximum(yplot)*1.1 ))\nend","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"plot the weight matrix before","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"p1 = Wplot(W_start;title=\"initial weights\")","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"plot weight after","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"p2 = Wplot(W_end;title=\"final weights\")","category":"page"},{"location":"plasticity_rate_based/#Result-2","page":"Rate-based plasticity rules","title":"Result","text":"","category":"section"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"The excitation tends to be much more distributed across the network, and it is still symmetric.","category":"page"},{"location":"plasticity_rate_based/#From-symmetric-to-asymmetric-STDP","page":"Rate-based plasticity rules","title":"From symmetric to asymmetric STDP","text":"","category":"section"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"An asymmetric STDP will force a directionality in the connection. Let's see how that turns out. Again take the regime of strong and sparse  so small (1+θ) and input current very close to target rate.","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"he = 5.0\nplasticity_ee_asymm_blanket = let A = 8E-7,\n  ree_targ = 5.01,\n  τ = 40E-3,\n  wee_max = 0.25,\n  γ = 1.0,\n  θ = -1.2,\n  αpre =  -ree_targ*(1+θ)\n  αpost = -ree_targ*(1+θ)\n  bounds=H.PlasticityBoundsLowHigh(wmin,wee_max)\n  H.PlasticityAsymmetricX(A,θ,τ,γ,αpre,αpost,ne,ne;\n      plasticity_bounds=bounds)\nend;\n\nH.reset!(ps_e)\nconnection_ee = H.ConnectionExpKernel(copy(W_start),tr_e,plasticity_ee_asymm_blanket);\nnothing #hide","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"define populations","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"pop_e = H.PopulationExpKernel(ps_e,fill(he,ne),(connection_ee,ps_e));\nnothing #hide","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"Record all spikes for a single population","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"rec_spk = H.RecFullTrain(n_spikes+1,1);\nnothing #hide","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"Record weights too","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"rec_wee = H.RecTheseWeights(connection_ee.weights,Δt_wrec,Tend_wrec);\nnothing #hide","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"define network:","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"netw = H.RecurrentNetworkExpKernel((pop_e,),(rec_spk,rec_wee));\nnothing #hide","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"Ready to run!","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"t_end = run_simulation!(netw,n_spikes;show_progress=false);\n@info \"\"\"\nSimulation completed at time $(round(t_end/60.0;digits=1)) min or $(round(t_end/3600.0;digits=2)) hours\n\"\"\"\n\n\nW_end = connection_ee.weights;\nnothing #hide","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"get weights","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"rec_weec = H.get_content(rec_wee)\ntimes_W = rec_weec.times\nWs = rec_weec.weights;\nnothing #hide","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"get spikes","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"recc_spk = H.get_content(rec_spk)\ntrains_e = H.get_trains(recc_spk;pop_idx=1)\n\ntimes_r, rates_insta_e = H.instantaneous_rates(trains_e,Δt_rates ,t_end);\nnothing #hide","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"plot the rates to show that they are more or less stable","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"plot(times_r ./ 60.0,rates_insta_e';\n  label=\"rates\",xlabel=\"time (min)\",ylabel=\"rate (Hz)\",linewidth=2,leg=false,\n  linecolor=:blue,opacity=0.5,\n  ylims=(0,maximum(rates_insta_e)*1.1))","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"plot the average weight, to check for stability","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"theplot = let yplot = mean.(Ws)\n  plot(times_W ./ 60.0,yplot;\n    label=\"average weight\",xlabel=\"time (min)\",ylabel=\"weight\",linewidth=5,leg=false,\n    linecolor=colorant\"orange\",opacity=0.5,\n    ylims=(0,maximum(yplot)*1.1 ))\nend","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"plot the weight matrix before","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"p1 = Wplot(W_start;title=\"initial weights\")","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"plot weight after","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"p2 = Wplot(W_end;title=\"final weights\")","category":"page"},{"location":"plasticity_rate_based/#Result-3","page":"Rate-based plasticity rules","title":"Result","text":"","category":"section"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"With an antisymmetric STDP, the system really likes saturation, but really dislikes symmetry. The weight matrix is nearly perferctly antisymmetric, you could play Tetris with it.","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"THE END","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"","category":"page"},{"location":"plasticity_rate_based/","page":"Rate-based plasticity rules","title":"Rate-based plasticity rules","text":"This page was generated using Literate.jl.","category":"page"},{"location":"alphadelay/#1D-Hawkes-process-with-delayed-alpha-kernel","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"","category":"section"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"In this example, I simulate either a 1D or a 2D Hawkes process, with a delayed-alpha interaction kernel","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"g(t) = H(t-t_textdelay)   frac(t-t_textdelay)tau^2 \n expleft(- frac(t-t_textdelay)tau right)","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"where H(x) is the Heaviside function: H(x)=0 for x0, H(x)=1 for tgeq 0.","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"Kernels are always normalized so that their integral is 1.","category":"page"},{"location":"alphadelay/#Initialization","page":"1D Hawkes process with delayed alpha kernel","title":"Initialization","text":"","category":"section"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"using LinearAlgebra,Statistics,StatsBase,Distributions\nusing Plots,NamedColors ; theme(:default) #; plotlyjs()\nusing FFTW\n\nusing ProgressMeter\nusing Random\nRandom.seed!(0)\n\nusing HawkesSimulator; const global H = HawkesSimulator","category":"page"},{"location":"alphadelay/#Define-and-visualize-the-kernel","page":"1D Hawkes process with delayed alpha kernel","title":"Define and visualize the kernel","text":"","category":"section"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"mytau = 0.5\nmydelay = 2.0\nmyw = fill(0.85,(1,1)) # 1x1 matrix\nmyinput = [0.5,]       # 1-dim vector\n\nker = H.KernelAlphaDelay(mytau,mydelay)\n\nplt = let ts = range(-0.5,8;length=150)\n  y = [H.interaction_kernel(_t,ker) for _t in ts]\n  plt=plot(ts,y ; linewidth=3,leg=false,xlabel=\"time (s)\",\n      ylabel=\"interaction kernel\")\n  ymax=ylims()[2]\n  plot!(plt,[0,0],[0,ymax];linestyle=:dash,linecolor=:black)\nend;\nplot(plt)","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"Note that the kernel starts after zero, according to the delay indicated.","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"As a side note: in order to simulate Hawkes processes, one always needs to define a non-increasing upper limit to the kernel. This is what it looks like for this kernel.","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"plt = let  ts = range(-0.5,8;length=150)\n  y = [H.interaction_kernel(_t,ker) for _t in ts]\n  yu = [H.interaction_kernel_upper(_t,ker) for _t in ts]\n  plt = plot(ts,y ; linewidth=3,xlabel=\"time (s)\",\n      ylabel=\"interaction kernel\", label=\"true kernel\")\n  plot!(plt, ts,yu ; linewidth=2, label=\"upper limit\", linestyle=:dash)\n  ymax=ylims()[2]\n  plot!(plt,[0,0],[0,ymax];linestyle=:dash,linecolor=:black,label=\"\")\nend;\nplot(plt)","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"the closer the upper limit is to the true kernel, the more efficient the simulation.","category":"page"},{"location":"alphadelay/#Build-the-network-and-run-it","page":"1D Hawkes process with delayed alpha kernel","title":"Build the network and run it","text":"","category":"section"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"I compare the final rate with what I expect from the analytic solution (see first example file)","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"pops = H.PopulationState(ker,1)\nntw = H.RecurrentNetwork(pops,myw,myinput)\n\nfunction run_simulation!(network,num_spikes,\n    t_flush_trigger=300.0,t_flush=100.0)\n  t_now = 0.0\n  H.reset!(network) # clear spike trains etc\n  @showprogress \"Running Hawkes process...\" for _ in 1:num_spikes\n    t_now = H.dynamics_step_singlepopulation!(t_now,network)\n    H.flush_trains!(network,t_flush_trigger;Tflush=t_flush)\n  end\n  H.flush_trains!(network) # flush everything into history\n  return t_now\nend\n\nn_spikes = 80_000\nTmax = run_simulation!(ntw,n_spikes);\n\nratenum = H.numerical_rates(pops)[1]\nrate_analytic = (I-myw)\\myinput\nrate_analytic = rate_analytic[1] # from 1-dim vector to scalar\n\n@info \"Mean rate -  numerical $(round(ratenum;digits=2)), analytic  $(round(rate_analytic;digits=2))\"","category":"page"},{"location":"alphadelay/#Covariance-density","page":"1D Hawkes process with delayed alpha kernel","title":"Covariance density","text":"","category":"section"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"First, compute covariance density numerically for a reasonable time step","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"mytrain = pops.trains_history[1]\nmydt = 0.1\nmyτmax = 60.0\nmytaus = H.get_times(mydt,myτmax)\nntaus = length(mytaus)\ncov_times,cov_num = H.covariance_self_numerical(mytrain,mydt,myτmax);\nnothing #hide","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"now compute covariance density analytically (as in Hawkes models), at higher resolution, and compare analytic and numeric","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"Note that the high resolution is not just for a better plot, but also to ensure the result is more precise when we move from frequency domain (Fourier transforms) to time domain.","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"function four_high_res(dt::Real,Tmax::Real) # higher time resolution, longer time\n  k1,k2 = 2 , 0.01\n  myτmax = Tmax * k1\n  dt *= k2\n  mytaus = H.get_times(dt,myτmax)\n  nkeep = div(length(mytaus),k1)\n  myfreq = H.get_frequencies_centerzero(dt,myτmax)\n  gfou = myw[1,1] .* H.interaction_kernel_fourier.(myfreq,Ref(ker)) |> ifftshift\n  ffou = let r=rate_analytic\n    covf(g) = r/((1-g)*(1-g'))\n    map(covf,gfou)\n  end\n  retf = real.(ifft(ffou))\n  retf[2:end] ./= dt # first element is rate\n  return mytaus[1:nkeep],retf[1:nkeep]\nend\n\ntaush,covfou=four_high_res(mydt,myτmax)\n\ntheplot = let plt = plot(xlabel=\"time delay (s)\",ylabel=\"Covariance density\")\n  plot!(plt,cov_times[2:end], cov_num[2:end] ; linewidth=3, label=\"numerical\" )\n  plot!(plt,taush[2:end],covfou[2:end]; label=\"analytic\",linewidth=3,linestyle=:dash)\nend;\nplot(theplot)","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"Analytics and numerics match quite well, although not perfectly. Whatever.","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"THE END","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"","category":"page"},{"location":"alphadelay/","page":"1D Hawkes process with delayed alpha kernel","title":"1D Hawkes process with delayed alpha kernel","text":"This page was generated using Literate.jl.","category":"page"},{"location":"plasticity_STDP/#Spiking-based-plasticity-rules-for-two-neurons","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"","category":"section"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"In this example, I show the effects of plasticity rules on a single pre-post connection between the two neurons. The neural activity is entirely regulated from the outside (e.g. the neurons do not interact through their weights). This is to better illustrate plasticity rules in their simplest form.","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"I also consider analytic results for purely Poisson firing (uncorrelated).","category":"page"},{"location":"plasticity_STDP/#Initialization","page":"Spiking-based plasticity rules for two neurons","title":"Initialization","text":"","category":"section"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"using LinearAlgebra,Statistics,StatsBase,Distributions\nusing Plots,NamedColors,LaTeXStrings ; theme(:default) ; gr()\n\nusing InvertedIndices\nusing ProgressMeter\nusing Random\nRandom.seed!(0)\n\nusing HawkesSimulator; const global H = HawkesSimulator","category":"page"},{"location":"plasticity_STDP/#Part-1:-Poisson-processes","page":"Spiking-based plasticity rules for two neurons","title":"Part 1: Poisson processes","text":"","category":"section"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"Here the neurons are uncorrelated Poisson processes.","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"The goal is to emphasize the rate-dependent part of plasticity, comparing pairwise STDP to triplet STDP","category":"page"},{"location":"plasticity_STDP/#Plasticity:-positive-biased-STPD-rule","page":"Spiking-based plasticity rules for two neurons","title":"Plasticity: positive biased STPD rule","text":"","category":"section"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"Here the weight change will depent linearly on pre and post rate.","category":"page"},{"location":"plasticity_STDP/#Functions-that-generate-spiketrains,-plasticity,-population,-etc","page":"Spiking-based plasticity rules for two neurons","title":"Functions that generate spiketrains, plasticity, population, etc","text":"","category":"section"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"this one generates the connection object","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"function do_2by2_connection(τplus::R,A2plus::R,τminus::R,A2minus::R;w_start::R=100.0) where R\n  N=2\n  _plast = HawkesSimulator.PairSTDP(τplus,τminus,A2plus,A2minus,N,N)\n  W = fill(w_start,N,N)\n  W[diagind(W)] .= 0.0\n  return H.ConnectionDenseWeights(W,_plast)\nend","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"this one generates spike trains, a network object, a weight recorder. It requres a connection","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"function population_trains(rate1::R,rate2::R,conn::H.Connection;\n    ttot::R=5_000.0,krec::Integer=400) where R\n  N = 2\n  trains =[ H.make_poisson_samples(rate1,ttot),\n             H.make_poisson_samples(rate2,ttot) ]\n  _ps = H.PopulationState(H.InputUnit(H.SGTrains(trains)),N)\n  pop = H.PopulationInputTestWeights(_ps,conn)\n  recweights = H.RecTheseWeights(conn.weights,ttot/krec,ttot)\n  ntw = H.RecurrentNetworkExpKernel(pop,recweights)\n  return recweights,ntw\nend","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"this put the previous two together","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"function plastic_two_neurons(τplus::R,A2plus::R,τminus::R,A2minus::R,rate1::R,rate2::R;\n    w_start::R=100.0,ttot::R=5_000.,krec=400) where R\n  conn = do_2by2_connection(τplus,A2plus,τminus,A2minus;w_start=w_start)\n  recweights,ntw = population_trains( rate1,rate2,conn; ttot=ttot,krec=krec)\n  return conn,recweights,ntw\nend","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"runs the network","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"function run_network01(ntw,conn,recweights,ttot)\n  H.reset!(ntw)\n  H.reset!(recweights)\n  w_start = copy(conn.weights)\n  _T=ttot-0.1\n  t_now = 0.0\n  prog = Progress(ceil(Integer,_T);dt=5)\n  while t_now <= _T\n    t_now = H.dynamics_step_singlepopulation!(t_now,ntw)\n    if t_now > _T\n      ProgressMeter.finish!(prog)\n    else\n      update!(prog,floor(Integer,t_now))\n    end\n  end\n  w_end = copy(conn.weights)\n  return w_start,w_end,t_now\nend","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"Utility functions to make nice plots","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"function mynormalize(mat::Matrix{<:Real})\n  _mi,_ma = extrema(mat)\n  hasminus = _mi < -1E-4\n  if hasminus\n    idxplus = mat .> 0\n    matnorm = similar(mat)\n    matnorm[idxplus] = mat[idxplus] ./ _ma\n    matnorm[Not(idxplus)] = mat[Not(idxplus)] ./ abs(_mi)\n  else\n    matnorm = mat ./ _ma\n  end\n  return hasminus,matnorm\nend\n\nfunction plot_nice_DW(r1::AbstractVector{R},r2::AbstractVector{R},DW::Matrix{R}) where R\n  rh = 0.5(r1[2]-r1[1])\n  colorh = colorant\"#F47D23\"\n  colorm = colorant\"white\"\n  colorl = colorant\"#147ABF\"\n  hasminus = minimum(DW) < -1E-2\n  if hasminus\n    _min,_max = extrema(DW)\n    _mid = -_min/(_max-_min)\n    myc = cgrad([colorl,colorm,colorh],[0,_mid,1.0])\n  else\n    myc = cgrad([colorm,colorh],[0,1.0])\n  end\n  _lims = (rh,rh+r1[end])\n  return heatmap(r1,r2,DW;\n    xlabel = L\"r_{\\mathrm{post}}\",\n    ylabel = L\"r_{\\mathrm{pre}}\",\n    xlims=_lims,ylims=_lims,\n    ratio=1, color=myc)\nend\nfunction plot_nice_DW_normed(r1::AbstractVector{R},r2::AbstractVector{R},DW::Matrix{R}) where R\n  colorh = colorant\"#F47D23\"\n  colorm = colorant\"white\"\n  colorl = colorant\"#147ABF\"\n  hasminus,DWn = mynormalize(DW)\n  if hasminus\n    myc = cgrad([colorl,colorm,colorh],[-1,0,1.0])\n  else\n    myc = cgrad([colorm,colorh],[0,1.0])\n  end\n  rh = 0.5(r1[2]-r1[1])\n  _lims = (rh,rh+r1[end])\n  return heatmap(r1,r2,DWn;\n    xlabel = L\"r_{\\mathrm{post}}\",\n    ylabel = L\"r_{\\mathrm{pre}}\",\n    xlims=_lims,ylims=_lims,\n    ratio=1,\n    color=myc)\nend","category":"page"},{"location":"plasticity_STDP/#Run-numerical-simulation-for-specific-parameters","page":"Spiking-based plasticity rules for two neurons","title":"Run numerical simulation for specific parameters","text":"","category":"section"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"const plast_eps = 1E-4\nconst A2plus = 1.0 * plast_eps\nconst τplus = 0.5\nconst A2minus = -0.7 * plast_eps\nconst τminus = 0.69\nconst rate1 = 10.\nconst rate2 = 15.0\nconst ttot = 1_000.0","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"plot weight change in time","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"theplot = let  (conn,recweights,ntw) =\n    plastic_two_neurons(τplus,A2plus,τminus,A2minus,rate1,rate2;ttot=ttot),\n  (w_start,w_end,t_end) = run_network01(ntw,conn,recweights,ttot)\n  plt = plot(size=(300,200))\n  ws12 = [_w[1,2] for _w in recweights.weights]\n  ws21 = [_w[2,1] for _w in recweights.weights]\n  wtimes = recweights.times\n  plot!(plt,wtimes,ws12;label=L\"$w_{12}$\",linewidth=2)\n  plot!(plt,wtimes,ws21;label=L\"$w_{21}$\",linewidth=2)\n  plot!(plt,xlabel=\"time (s)\",ylabel=\"weight\",leg=:topleft,\n    title=\"\")\n  plt\nend\nplot(theplot)","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"The STDP rule is potentiation dominated, so the weights grow linearly.","category":"page"},{"location":"plasticity_STDP/#Run-numerical-simulation-for-varying-rates","page":"Spiking-based plasticity rules for two neurons","title":"Run numerical simulation for varying rates","text":"","category":"section"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"const nrates = 20\nconst rates1 = range(0.1,45.;length=nrates)\nconst rates2 = copy(rates1)\nconst DW12 = Matrix{Float64}(undef,nrates,nrates)\n\nconst plast_eps = 1E-4\nconst A2plus = 1.0 * plast_eps\nconst τplus = 0.5\nconst A2minus = -0.7 * plast_eps\nconst τminus = 0.69\nconst ttot = 1_000.0\n\n@showprogress for ij in CartesianIndices(DW12)\n  conn,recweights,ntw = plastic_two_neurons(τplus,A2plus,τminus,A2minus,\n    rates1[ij[1]],rates2[ij[2]];ttot=ttot)\n  (w_start,w_end,t_end) = run_network01(ntw,conn,recweights,ttot)\n  DW12[ij] = w_end[1,2] - w_start[1,2]\nend\n\nplot_nice_DW(rates1,rates2,DW12)","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"compare with analytic values","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"rates_an = range(0.1,45.;length=150)\nDW12_analytic_dense = let c = A2plus*τplus + A2minus*τminus\n  (c*ttot) .* (rates_an * rates_an')\nend\n\ntheplot = let  c = A2plus*τplus + A2minus*τminus\n  DW12_analytic = (c*ttot) .* (rates1 * rates2')\n  plt = plot()\n  scatter!(plt,DW12[:],DW12_analytic[:],color=:black)\n  plot!(plt,identity,ratio=1,xlabel=\"numeric\",ylabel=\"analytic\",linestyle=:dash,linewidth=3,\n    color=:yellow,leg=false)\nend","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"show the analytic heatmap","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"plot_nice_DW_normed(rates_an,rates_an,DW12_analytic_dense)","category":"page"},{"location":"plasticity_STDP/#Plasticity-:-triplet-STDP-with-usual-parameters","page":"Spiking-based plasticity rules for two neurons","title":"Plasticity : triplet STDP with usual parameters","text":"","category":"section"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"I will go straight to the part where I consider multiple rates","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"this one generates the connection object","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"function do_2by2_connection_triplets(τplus::R,A2plus::R,τminus::R,A2minus::R,\n     τx::R,A3plus::R,τy::R,A3minus::R;w_start::R=100.0) where R\n  N=2\n  _plast = HawkesSimulator.PlasticityTriplets(τplus,τminus,τx,τy,A2plus,A3plus,A2minus,A3minus,N,N)\n  W = fill(w_start,N,N)\n  W[diagind(W)] .= 0.0\n  return H.ConnectionDenseWeights(W,_plast)\nend","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"this put the previous two together","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"function plastic_two_neurons_triplets(τplus::R,A2plus::R,τminus::R,A2minus::R,\n    τx::R,A3plus::R,τy::R,A3minus::R,rate1::R,rate2::R;\n    w_start::R=100.0,ttot::R=5_000.,krec=400) where R\n  conn = do_2by2_connection_triplets(τplus,A2plus,τminus,A2minus,τx,A3plus,τy,A3minus;w_start=w_start)\n  recweights,ntw = population_trains( rate1,rate2,conn; ttot=ttot,krec=krec)\n  return conn,recweights,ntw\nend\n\n\nconst nrates = 20\nconst rates1 = range(0.1,45.;length=nrates)\nconst rates2 = copy(rates1)\nconst DW12 = Matrix{Float64}(undef,nrates,nrates)","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"parameters considered as \"standard\" for triplet STDP rule","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"const plast_eps = 1E-3\n\nconst\tA2plus  = 7.5E-7 *plast_eps\nconst\tA2minus = -7.0   *plast_eps\nconst\tA3plus  = 6.0    *plast_eps  # 9.3\nconst\tA3minus = -0.23  *plast_eps\n\nconst τplus = 17E-3\nconst τminus = 34E-3\nconst τy = 101E-3\nconst τx = 125E-3","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"run simulation for varying rates","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"@showprogress for ij in CartesianIndices(DW12)\n  conn,recweights,ntw = plastic_two_neurons_triplets(τplus,A2plus,τminus,A2minus,\n    τx,A3plus,τy,A3minus,\n    rates1[ij[1]],rates2[ij[2]];ttot=ttot)\n  (w_start,w_end,t_end) = run_network01(ntw,conn,recweights,ttot)\n  DW12[ij] = w_end[1,2] - w_start[1,2]\nend","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"show result","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"plot_nice_DW(rates1,rates2,DW12)","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"compare with analytics","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"compare with analytic values","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"rates_dense = range(0.1,45.;length=150)\nDW12_analytic_dense = let r1r1 =  rates_dense * rates_dense'\n  r2r1 = (rates_dense.^2)*rates_dense'\n  r1r2 = rates_dense*(rates_dense.^2)'\n  c11 = A2plus*τplus + A2minus*τminus\n  c12 = A3minus*τminus*τx\n  c21 = A3plus*τplus*τy\n  @. ttot * (c11*r1r1 + c12*r1r2 + c21*r2r1)\nend\n\ntheplot = let r1r1 =  rates1 * rates2'\n  r2r1 = (rates1.^2)*rates2'\n  r1r2 = rates1*(rates2.^2)'\n  c11 = A2plus*τplus + A2minus*τminus\n  c12 = A3minus*τminus*τx\n  c21 = A3plus*τplus*τy\n  DW12_analytic =  @. ttot * (c11*r1r1 + c12*r1r2 + c21*r2r1)\n  plt = plot()\n  scatter!(plt,DW12[:],DW12_analytic[:],color=:black)\n  plot!(plt,identity,ratio=1,xlabel=\"numeric\",ylabel=\"analytic\",linestyle=:dash,linewidth=3,\n    color=:yellow,leg=false)\nend\nplot(theplot)","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"show the analytic heatmap","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"plot_nice_DW_normed(rates_an,rates_an,DW12_analytic_dense)","category":"page"},{"location":"plasticity_STDP/#Part-2-:-pairing-protocol","page":"Spiking-based plasticity rules for two neurons","title":"Part 2 : pairing protocol","text":"","category":"section"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"Here  neurons are forced to spike as in typical STDP experimental protocols. That is, they both fire at the same  rate, but with a time difference set to a certain Delta t.","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"function post_pre_spiketrains(rate::R,Δt_ro::R,Ttot::R;\n    tstart::R = 0.05) where R\n  post = collect(range(tstart,Ttot; step=inv(rate)))\n  pre = post .- Δt_ro\n  return [pre,post]\nend","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"let's take a look at one example: rate of 5.0 Hz, 20 ms difference in spike time","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"_ = let trains = post_pre_spiketrains(5.0,20E-3,1.0)\n  plt = plot()\n  scatter!(plt,trains[1], 0.1 .+ zero(trains[1]),markersize=30,\n      markercolor=:black,markershape=:vline,leg=false)\n  scatter!(plt,trains[2], 0.2 .+ zero(trains[2]),markersize=30,\n      markercolor=:black,markershape=:vline,leg=false)\n  plot!(plt,ylims=(0.0,0.3),xlims=(0,1),xlabel=\"time (s)\")\nend","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"Now I define a population of input neurons using this input protocol. The Population object includes the weight matrix and the plasticity rules associated to it, both wrapped in the Connection object. I consider the connection as an input parameter of this function, to be set externally with the desired plasticity rule.","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"Note that I define the population as PopulationInputTestWeights to indicate non-interacting weights","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"function post_pre_population(rate::Real,nreps::Integer,Δt_ro::Real,connection::H.Connection)\n  Ttot = nreps/rate\n  prepostspikes = post_pre_spiketrains(rate,Δt_ro,Ttot)\n  gen = H.SGTrains(prepostspikes)\n  state = H.PopulationState(H.InputUnit(gen),2)\n  return H.PopulationInputTestWeights(state,connection)\nend","category":"page"},{"location":"plasticity_STDP/#Constructors","page":"Spiking-based plasticity rules for two neurons","title":"Constructors","text":"","category":"section"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"Here I define a function that tests the plasticity rule. That is, given a Δt, it creates the input neurons, then it defines a network, and iterates it dynamically for a certain number of pre-post repetitions. Finally it outputs the weight total change divided by time (so it's a weight change per second)","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"Since both neurons have the same plasticity rule, a positive pre-post Delta t for neuron A, impacting the  w_textAB weight, is the equivalent of a negative pre-post Delta t for neuron B, impacting the w_textBA weight.","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"function test_stpd_rule(Δt::Real,connection::H.Connection;\n    nreps=510,wstart=100.0,rate=0.5)\n  num_spikes = nreps*2 - 10 # a bit less than total, for safety\n  recorder = H.RecFullTrain(num_spikes)\n  population = post_pre_population(rate,nreps,Δt,connection)\n  network = H.RecurrentNetworkExpKernel(population,recorder)\n  wmat = connection.weights\n  fill!(wmat,wstart)\n  wmat[diagind(wmat)] .= 0.0\n  t_now = 0.0\n  H.reset!.((network,recorder,connection)) # clear spike trains etc\n  for _ in 1:num_spikes\n    t_now = H.dynamics_step_singlepopulation!(t_now,network)\n  end\n  w12,w21 = wmat[1,2],wmat[2,1]\n  H.reset!(network)\n  dw12 = (w12-wstart)/t_now\n  dw21 = (w21-wstart)/t_now\n  return dw12,dw21\nend","category":"page"},{"location":"plasticity_STDP/#STDP-rule","page":"Spiking-based plasticity rules for two neurons","title":"STDP rule","text":"","category":"section"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"Here I define the plasticty type and the parameters that I want to test. I choose the pairwise STDP rule. I initialize the weight matrix to 100.0","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"Note once again that neurons are not interacting. The sole purpose of the \"dummy\" weights it to be changed by plasticity.","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"connection_test = let wmat =  fill(100.0,2,2)\n  wmat[diagind(wmat)] .= 0.0\n  τplus = 10E-3\n  τminus = 10E-3\n  Aplus = 1E-1\n  Aminus = -1E-1\n  npost,npre = size(wmat)\n  stdp_plasticity = H.PairSTDP(τplus,τminus,Aplus,Aminus,npost,npre)\n  H.ConnectionDenseWeights(wmat,stdp_plasticity)\nend","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"let's do one run","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"dw12,dw21 = test_stpd_rule(2E-3,connection_test)\nprintln(\"change in w12 : $(dw12), change in w21 $(dw21)\")","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"Neuron 1 spikes before neuron 2, therefore connection from 1 to 2, dw21 is potentiated, while connection from 2 to 1, dw12 is depressed.","category":"page"},{"location":"plasticity_STDP/#STDP-curve","page":"Spiking-based plasticity rules for two neurons","title":"STDP curve","text":"","category":"section"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"Compute and plot the weight changes due to STDP for varying Delta ts","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"nsteps = 200\ndeltats = range(0.1E-3,100E-3;length=nsteps)\ndeltats_all = vcat(-reverse(deltats),deltats)\nout = Vector{Float64}(undef,2*nsteps)\n\nfor (i,Δt) in enumerate(deltats)\n  dw12,dw21 = test_stpd_rule(Δt,connection_test)\n  out[nsteps+i]=dw21\n  out[nsteps-i+1]=dw12\nend\n\n\nplot(deltats_all,out;leg=false,xlabel=\"Delta t\",ylabel=\"dw/dt\",linewidth=3)","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"Pairing protocol with symmetric STDP rule","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"I will do the same as above, but in a slightly different way. I will consider completely random Delta ts values so every single update is different, and I can check all of them at the same time! BUT now I need to save the weights at each step. So I need to store weight at each event! (I can't use a weight recorder for that, because weight recorder is not event-based, but instead stores the weight according to its internal Delta t)","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"function post_pre_spiketrains_morerandom(rate::R,Δt_boundary::R,Ntot::Integer) where R\n  tstart = 1.5/rate\n  post = collect(range(tstart;length=Ntot,step=inv(rate)))\n  Δts  = rand(Uniform(-Δt_boundary,Δt_boundary),Ntot)\n  pre = sort!(post .+ Δts)\n  return (Δts,[pre,post])\nend\n\nfunction post_pre_population_morerandom(rate::R,\n    Δt_boundary::R,Ntot::Integer,connection::H.Connection) where R\n  Δts,prepostspikes = post_pre_spiketrains_morerandom(rate,Δt_boundary,Ntot)\n  gen = H.SGTrains(prepostspikes)\n  state = H.PopulationState(H.InputUnit(gen),2)\n  return Δts, H.PopulationInputTestWeights(state,connection)\nend\n\nfunction test_stpd_symmetric_rule(rate::R,\n    Δt_boundary::R,Ntot::Integer,connection::H.Connection;\n    wstart=100.0) where R\n  num_spikes = 2*Ntot\n  Δts,population = post_pre_population_morerandom(rate,Δt_boundary,Ntot,connection)\n  network = H.RecurrentNetworkExpKernel(population)\n  wmat = connection.weights\n  ws = Vector{Float64}(undef,num_spikes)\n  fill!(wmat,wstart)\n  wmat[diagind(wmat)] .= 0.0\n  t_now = 0.0\n  H.reset!.((network,connection)) # clear spike trains etc\n  for k in 1:num_spikes\n    t_now = H.dynamics_step_singlepopulation!(t_now,network)\n    ws[k] = wmat[1,2]\n  end\n  Δws = diff(ws)[1:2:end]\n  return Δts , ws, Δws\nend\n\n\nmyτplus = 10E-3\nmyτminus = 30E-3\nmyAplus = 1E-1\nmyAminus = -0.5E-1\n\nfunction expected_symm_stdp(Δt::Real)\n  return myAplus*exp(-abs(Δt)/myτplus) + myAminus*exp(-abs(Δt)/myτminus)\nend\n\nconnection_test = let wmat =  fill(100.0,2,2)\n  wmat[diagind(wmat)] .= 0.0\n  npost,npre = size(wmat)\n  stdp_plasticity = H.SymmetricSTDP(myτplus,myτminus,myAplus,myAminus,npost,npre)\n  H.ConnectionDenseWeights(wmat,stdp_plasticity)\nend\n\ntheplot = let myrate = 0.1\n  mybound = 100E-3\n  myNtest  = 800\n  xplot = range(-mybound,mybound,length=150)\n  delta_ts,testws, testDws = test_stpd_symmetric_rule(myrate,mybound,myNtest,connection_test)\n  scatter(delta_ts,testDws, xlabel=\"Delta t\",ylabel=\"dw/dt\",\n    label=\"numeric\", title=\"Symmetric STDP\")\n  plot!(xplot, expected_symm_stdp.(xplot),linewidth=2,linestyle=:dash,color=:red,\n    label=\"analytic\")\nend\n\n# src","category":"page"},{"location":"plasticity_STDP/#Fancy-generalized-symmetric-rule","page":"Spiking-based plasticity rules for two neurons","title":"Fancy generalized symmetric rule","text":"","category":"section"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"Here I show a more general symmetric rule that incorporates some bias terms that depend on pre and post firing rate. Some of the functions are re-used from above","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"A = -0.1;\nnothing #hide","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"time constants, use γ>1 for long tail with depression","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"τ = 10E-3\nγ = 3.0;\nnothing #hide","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"The bias on rpre*rpost is A*(1+θ) Set to -1.0 for no bias, >-1.0 for negative bias, <-1 for positive bias","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"θ = -1.0;\nnothing #hide","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"This is the bias on r_pre","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"αpre = -1.0;\nnothing #hide","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"This is the bias on r_post","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"αpost = 3.0;\n\nfunction expected_symmX_stdp(Δt::Real)\n  myAplus = A/τ\n  myAminus =θ*A/(γ*τ)\n  myτplus = τ\n  myτminus = γ*τ\n  b =  Δt>0 ? A*αpost : A*αpre\n  return b + myAplus*exp(-abs(Δt)/myτplus) + myAminus*exp(-abs(Δt)/myτminus)\nend\n\nconnection_testX = let wmat =  fill(100.0,2,2)\n  wmat[diagind(wmat)] .= 0.0\n  npost,npre = size(wmat)\n  _plasticity = H.PlasticitySymmetricSTDPX(A,θ,τ,γ,αpre,αpost,npost,npre)\n  H.ConnectionDenseWeights(wmat,_plasticity)\nend\n\ntheplot = let myrate = 0.05\n  mybound = 100E-3\n  myNtest  = 800\n  xplot = range(-mybound,mybound,length=150)\n  delta_ts,testws, testDws = test_stpd_symmetric_rule(myrate,mybound,myNtest,connection_testX)\n  scatter(delta_ts,testDws, xlabel=\"Delta t\",ylabel=\"dw/dt\",\n    label=\"numeric\", title=\"Generalized Symmetric STDP\")\n  plot!(xplot, expected_symmX_stdp.(xplot),linewidth=2,linestyle=:dash,color=:red,\n    label=\"analytic\")\nend","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"How weird!","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"# src","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"THE END","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"","category":"page"},{"location":"plasticity_STDP/","page":"Spiking-based plasticity rules for two neurons","title":"Spiking-based plasticity rules for two neurons","text":"This page was generated using Literate.jl.","category":"page"},{"location":"exp_1and2D/#1D-and-2D-Hawkes-processes-with-exponential-kernel","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"","category":"section"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"In this example, I simulate first a 1D self-exciting Hawkes process and then a 2D one. The interaction kernel is an exponentially decaying function, defined as:","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"g(t) = H(t)   frac1tau  expleft(- fracttau right)","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"where H(t) is the Heaviside function: zero for t0, one for tgeq 0.","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"Note that Kernels are always normalized so that their integral between -infty and +infty is 1.","category":"page"},{"location":"exp_1and2D/#Initialization","page":"1D and 2D Hawkes processes with exponential kernel","title":"Initialization","text":"","category":"section"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"using LinearAlgebra,Statistics,StatsBase,Distributions\nusing Plots,NamedColors ; theme(:default) ; gr()\nusing FFTW\n\nusing ProgressMeter\nusing Random\nRandom.seed!(0)\n\nusing HawkesSimulator; const global H = HawkesSimulator\n\n\"\"\"\n    onedmat(x::R) where R\nGenerates a 1-by-1 Matrix{R} that contains `x` as only element\n\"\"\"\nfunction onedmat(x::R) where R\n  return cat(x;dims=2)\nend;\nnothing #hide","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"First I define the kernel, and the self-interaction weight.","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"myw is a scaling factor (the weight of the autaptic connection). The baseline rate is given by myinput","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"mytau = 0.5  # kernel time constant\nmyw = onedmat(0.85) # weight: this needs to be a matrix\nmyinput = [0.7,] # this needs to be a vector\nmykernel = H.KernelExp(mytau);\nnothing #hide","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"This is the plot of the (self) interaction kernel (before  the scaling by myw)","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"theplot = let ts = range(-1.0,5;length=150),\n  y = map(t->H.interaction_kernel(t,mykernel) , ts )\n  plot(ts , y ; linewidth=3,leg=false,xlabel=\"time (s)\",\n    color = :black,\n     ylabel=\"interaction kernel\")\nend;\nplot(theplot)","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"Now I build the network, using the simplified constructor for one-population networks. The object PopulationState initializes a population of Hawkes neurons of the specified size (1, in this case) and the kernel mykernel neurons in the same population all have the same kernel. (this might be an inconvenience if one wants qualitatively different self-connections... but it might be fixed in future versions)","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"popstate = H.PopulationState(mykernel,1)\nntw = H.RecurrentNetwork(popstate,myw,myinput);\nnothing #hide","category":"page"},{"location":"exp_1and2D/#Simulation","page":"1D and 2D Hawkes processes with exponential kernel","title":"Simulation","text":"","category":"section"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"The length of the simulation is measured by the total number of spikes here called num_spikes. The function flush_trains!(...) is used to store older spikes as history and let them be ignored by the kernels. The time parameters should be regulated based on the kernel shape.","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"function run_simulation!(network,num_spikes,\n    t_flush_trigger=300.0,t_flush=100.0)\n  t_now = 0.0\n  H.reset!(network) # clear spike trains etc\n  @showprogress \"Running Hawkes process...\" for _ in 1:num_spikes\n    t_now = H.dynamics_step_singlepopulation!(t_now,network)\n    H.flush_trains!(network,t_flush_trigger;Tflush=t_flush)\n  end\n  H.flush_trains!(network) # flush everything into history\n  return t_now\nend\n\nn_spikes = 100_000\nTmax = run_simulation!(ntw,n_spikes)\nratenum = H.numerical_rates(popstate;Tend=Tmax)[1]\n@info \"Simulation completed, mean rate $(round(ratenum;digits=2)) Hz\"\n\n#","category":"page"},{"location":"exp_1and2D/#Visualize-raster-plot-of-the-events","page":"1D and 2D Hawkes processes with exponential kernel","title":"Visualize raster plot of the events","text":"","category":"section"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"the raster plot shows some correlation between the neural activities neuron one (lower row) excites neuron two (upper row)","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"function rasterplot(tlims = (1100.,1120.) )\n  _train = popstate.trains_history[1]\n  plt=plot()\n  train = filter(t-> tlims[1]< t < tlims[2],_train)\n  nspk = length(train)\n  scatter!(plt,train,fill(0.1,nspk),markersize=30,\n      markercolor=:black,markershape=:vline,leg=false)\n  return plot!(plt,ylims=(0.0,0.2),xlabel=\"time (s)\")\nend\n\nrasterplot()","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"event times are always stored in pops.trains_history","category":"page"},{"location":"exp_1and2D/#Plot-the-instantaneous-rate","page":"1D and 2D Hawkes processes with exponential kernel","title":"Plot the instantaneous rate","text":"","category":"section"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"This is the probability of a spike given the past activity up until that moment. It is usually denoted by lambda^*(t).","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"function get_insta_rate(t,popstate)\n  _train = popstate.trains_history[1]\n  myinput[1] + H.interaction(t,_train,myw[1],popstate.unittype)\nend\nfunction plot_instarate(popstate,tlims=(1100,1120))\n  tplot = range(tlims...;length=100)\n  _train = popstate.trains_history[1]\n  tspk = filter(t-> tlims[1]<=t<=tlims[2],_train) # add the exact spiketimes for cleaner plot\n  tplot = sort(vcat(tplot,tspk,tspk .- 1E-4))\n  plt=plot(xlabel=\"time (s)\",ylabel=\"instantaneous rate\")\n  plot!(plt,t->get_insta_rate(t,popstate),tplot;linewidth=2,color=:black)\n  scatter!(t->get_insta_rate(t,popstate),tspk;leg=false)\n  avg_rate = H.numerical_rates(popstate;Tend=Tmax)[1]\n  ylim2 = ylims()[2]\n  plot!(plt,tplot, fill(avg_rate,length(tplot)),\n     color=:red,linestyle=:dash,ylims=(0,ylim2))\nend\nplot_instarate(popstate)","category":"page"},{"location":"exp_1and2D/#Plot-the-total-event-counts","page":"1D and 2D Hawkes processes with exponential kernel","title":"Plot the total event counts","text":"","category":"section"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"Total number of events as a function of time. It grows linearly, and the steepness is pretty much the rate.","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"function plot_counts(tlims=(0.,1000.))\n  avg_rate = H.numerical_rates(popstate;Tend=Tmax)[1]\n  tplot = range(tlims...;length=100)\n  _train = popstate.trains_history[1]\n  nevents(tnow::Real) = count(t-> t <= tnow,_train)\n  plt=plot(xlabel=\"time (s)\",ylabel=\"number of events\",leg=false)\n  plot!(plt,tplot,nevents.(tplot),color=:black,linewidth=2)\n  plot!(plt,tplot , tplot .* avg_rate,color=:red,linestyle=:dash)\nend\nplot_counts()","category":"page"},{"location":"exp_1and2D/#Rate","page":"1D and 2D Hawkes processes with exponential kernel","title":"Rate","text":"","category":"section"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"Now I compare the numerical rate with the analytic solution.","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"The analytic rate corresponds to the stationary solution of a linear dynamical system (assumung all stationary rates are above zero).","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"fracmathrm d mathbf rmathrm d t = - mathbf r + Wr + mathbf h quad\nqquad  r_infty = (I-W)^-1  mathbf h","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"rate_analytic = inv(I-myw)*myinput\nrate_analytic = rate_analytic[1] # 1-D , just a scalar\n\n@info \"Mean rate -  numerical $(round(ratenum;digits=2)), analytic  $(round(rate_analytic;digits=2))\"","category":"page"},{"location":"exp_1and2D/#Covariance-density","page":"1D and 2D Hawkes processes with exponential kernel","title":"Covariance density","text":"","category":"section"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"Definition:","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"C(tau) = left left( S(t) - r right) left( S(t-tau) - r right) right_t","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"Where r is the mean rate, and S(t) is the spike train.","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"Here I compute it numerically.","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"mytrain = popstate.trains_history[1]\nmydt = 0.1\nmyτmax = 25.0\nmytaus = H.get_times(mydt,myτmax)\nntaus = length(mytaus)\ncov_times,cov_num = H.covariance_self_numerical(mytrain,mydt,myτmax);\nnothing #hide","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"Now I compute the covariance density analytically, at higher resolution, and I compare the two.","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"function four_high_res(dt::Real,Tmax::Real) # higher time resolution, longer time\n  k1,k2 = 2 , 0.01\n  myτmax = Tmax * k1\n  dt *= k2\n  mytaus = H.get_times(dt,myτmax)\n  nkeep = div(length(mytaus),k1)\n  myfreq = H.get_frequencies_centerzero(dt,myτmax)\n  gfou = myw[1,1] .* H.interaction_kernel_fourier.(myfreq,Ref(popstate)) |> ifftshift\n  ffou = let r=rate_analytic\n    covf(g) = r/((1-g)*(1-g'))\n    map(covf,gfou)\n  end\n  retf = real.(ifft(ffou)) ./ dt\n  retf[1] *= dt  # first element is rate\n  return mytaus[1:nkeep],retf[1:nkeep]\nend\n\n(taush,covfou)=four_high_res(mydt,myτmax)\n\ntheplot =  let  plt = plot(xlabel=\"time delay (s)\",ylabel=\"Covariance density\")\n  plot!(plt,cov_times[2:end], cov_num[2:end] ; linewidth=3, label=\"simulation\" )\n  plot!(plt,taush[2:end],covfou[2:end]; label=\"analytic\",linewidth=3,linestyle=:dash)\n  plt\nend;\nplot(theplot)","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"1D system completed !","category":"page"},{"location":"exp_1and2D/#2D-Hawkes-process,-same-stuff","page":"1D and 2D Hawkes processes with exponential kernel","title":"2D Hawkes process, same stuff","text":"","category":"section"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"myτ = 1/2.33\nmywmat = [ 0.31   0.3\n           0.9  0.15 ]\nmyin = [1.0,0.1]\np1 = H.KernelExp(myτ)\nps1 = H.PopulationState(p1,2)\nntw = H.RecurrentNetwork(ps1,mywmat,myin);\nnothing #hide","category":"page"},{"location":"exp_1and2D/#Start-the-simulation","page":"1D and 2D Hawkes processes with exponential kernel","title":"Start the simulation","text":"","category":"section"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"the function run_simulation!(...) has been defined above Note that n_spikes is the total number of spikes among all units in the system.","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"n_spikes = 500_000\n\nTmax = run_simulation!(ntw,n_spikes,100.0,10.0);\nnothing #hide","category":"page"},{"location":"exp_1and2D/#Rates:-numeric-Vs-analytic","page":"1D and 2D Hawkes processes with exponential kernel","title":"Rates: numeric Vs analytic","text":"","category":"section"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"The analytic rate is from  Eq between 6 and  7 in Hawkes 1971","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"num_rates = H.numerical_rates(ps1)\nmyspikes_both = ps1.trains_history\n\nratefou = let G0 =  mywmat .* H.interaction_kernel_fourier(0,p1)\n  inv(I-G0)*myin |> real\nend\nrate_analytic = inv(I-mywmat)*myin\n\n@info \"Total duration $(round(Tmax;digits=1)) s\"\n@info \"Rates are $(round.(num_rates;digits=2))\"\n@info \"Analytic rates are $(round.(rate_analytic;digits=2)) Hz\"","category":"page"},{"location":"exp_1and2D/#Covariance-density-2","page":"1D and 2D Hawkes processes with exponential kernel","title":"Covariance density","text":"","category":"section"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"there are 4 combinations, therefore I will compare 4 lines.","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"mydt = 0.1\nmyτmax = 15.0\nmytaus = H.get_times(mydt,myτmax)\nntaus = length(mytaus)\ncov_times,cov_num = H.covariance_density_numerical(myspikes_both,mydt,myτmax)\n\ntheplot = let  plt=plot(xlabel=\"time delay (s)\",ylabel=\"Covariance density\")\n  for i in 1:2, j in 1:2\n    plot!(plt,cov_times[2:end-1],cov_num[2:end-1,i,j], linewidth = 3, label=\"cov $i-$j\")\n  end\n  plt\nend;\nplot(theplot)","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"The analytic solution is eq 12 from Hawkes 1971","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"function four_high_res(dt::Real,Tmax::Real)\n  k1 = 2\n  k2 = 0.005\n  myτmax,mydt = Tmax * k1, dt*k2\n  mytaus = H.get_times(mydt,myτmax)\n  nkeep = div(length(mytaus),k1)\n  myfreq = H.get_frequencies_centerzero(mydt,myτmax)\n  G_omega = map(mywmat) do w\n    ifftshift( w .* H.interaction_kernel_fourier.(myfreq,Ref(p1)))\n  end\n  D = Diagonal(ratefou)\n  M = Array{ComplexF64}(undef,length(myfreq),2,2)\n  Mt = similar(M,Float64)\n  for k in eachindex(myfreq)\n    G = getindex.(G_omega,k)\n    M[k,:,:] = (I-G)\\D/(I-G')\n  end\n  for i in 1:2,j in 1:2\n    Mt[:,i,j] = real.(ifft(M[:,i,j]))\n    Mt[2:end,i,j] ./= mydt # diagonal of t=0 contains the rate\n  end\n  return mytaus[1:nkeep],Mt[1:nkeep,:,:]\nend\n\ntaush,Cfou=four_high_res(mydt,myτmax)\n\nfunction oneplot(i,j)\n  plt=plot(xlabel=\"time delay (s)\",ylabel=\"Covariance density\",title=\"cov $i - $j\")\n  plot!(plt,mytaus[2:end],cov_num[2:end,i,j] ; linewidth = 3, label=\"simulation\")\n  plot!(plt,taush[2:end],Cfou[2:end,i,j]; linestyle=:dash, linewidth=3, label=\"analytic\")\nend","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"1","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"oneplot(1,1)","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"2","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"oneplot(1,2)","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"3","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"oneplot(2,1)","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"4","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"oneplot(2,2)","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"THE END","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"","category":"page"},{"location":"exp_1and2D/","page":"1D and 2D Hawkes processes with exponential kernel","title":"1D and 2D Hawkes processes with exponential kernel","text":"This page was generated using Literate.jl.","category":"page"},{"location":"plasticity_STDP_ratecompare/#Comparison-of-STDP-rules-in-the-rate-dominated-regime","page":"Comparison of STDP rules in the rate-dominated regime","title":"Comparison of STDP rules in the rate-dominated regime","text":"","category":"section"},{"location":"plasticity_STDP_ratecompare/","page":"Comparison of STDP rules in the rate-dominated regime","title":"Comparison of STDP rules in the rate-dominated regime","text":"This example is both a proof of concept, and a way to test that ALL my STDP rules are implemented correctly.","category":"page"},{"location":"plasticity_STDP_ratecompare/","page":"Comparison of STDP rules in the rate-dominated regime","title":"Comparison of STDP rules in the rate-dominated regime","text":"I will first consider uncorrelated neurons, and the ΔW over time.","category":"page"},{"location":"plasticity_STDP_ratecompare/","page":"Comparison of STDP rules in the rate-dominated regime","title":"Comparison of STDP rules in the rate-dominated regime","text":"Then I will consider an I to E connection, and check that converges to the expected values.","category":"page"},{"location":"plasticity_STDP_ratecompare/","page":"Comparison of STDP rules in the rate-dominated regime","title":"Comparison of STDP rules in the rate-dominated regime","text":"This example also shows the different parametrizations that I used for each rulle (all different! LOL)","category":"page"},{"location":"plasticity_STDP_ratecompare/#Initialization","page":"Comparison of STDP rules in the rate-dominated regime","title":"Initialization","text":"","category":"section"},{"location":"plasticity_STDP_ratecompare/","page":"Comparison of STDP rules in the rate-dominated regime","title":"Comparison of STDP rules in the rate-dominated regime","text":"using LinearAlgebra,Statistics,StatsBase,Distributions\nusing Plots,NamedColors,LaTeXStrings ; theme(:default) ; gr()\n\nusing InvertedIndices\nusing ProgressMeter\nusing Random\nRandom.seed!(0)\n\nusing HawkesSimulator; const global H = HawkesSimulator","category":"page"},{"location":"plasticity_STDP_ratecompare/#Utility-functions","page":"Comparison of STDP rules in the rate-dominated regime","title":"Utility functions","text":"","category":"section"},{"location":"plasticity_STDP_ratecompare/","page":"Comparison of STDP rules in the rate-dominated regime","title":"Comparison of STDP rules in the rate-dominated regime","text":"\"\"\"\n  plotvs(x::AbstractArray{<:Real},y::AbstractArray{<:Real})\n\nPlots X vs Y, and also the identity line.\n\"\"\"\nfunction plotvs(x::AbstractArray{<:Real},y::AbstractArray{<:Real})\n  x,y=x[:],y[:]\n  @info \"\"\"\n  The max differences between the two are $(extrema(x .-y ))\n  \"\"\"\n  plt=plot()\n  scatter!(plt,x,y;leg=false,ratio=1,color=:black,opacity=0.5)\n  lm=xlims()\n  plot!(plt,identity,range(lm...;length=3);linestyle=:dash,\n    color=colorant\"dark orange\", opacity=0.5,linewidth=3)\n  return plt\nend\n\nfunction absolute_errors(x::AbstractArray{<:Real},y::AbstractArray{<:Real})\n  x,y=x[:],y[:]\n  return abs.(x .-y )\nend\nfunction relative_errors(x::AbstractArray{<:Real},y::AbstractArray{<:Real})\n  x,y=x[:],y[:]\n  _m = @. max(abs(x),abs(y))\n  return @. abs((x-y)/_m)\nend","category":"page"},{"location":"plasticity_STDP_ratecompare/#Part-1-,-uncorrelated-pair-of-neurons","page":"Comparison of STDP rules in the rate-dominated regime","title":"Part 1 , uncorrelated pair of neurons","text":"","category":"section"},{"location":"plasticity_STDP_ratecompare/#General-functions","page":"Comparison of STDP rules in the rate-dominated regime","title":"General functions","text":"","category":"section"},{"location":"plasticity_STDP_ratecompare/","page":"Comparison of STDP rules in the rate-dominated regime","title":"Comparison of STDP rules in the rate-dominated regime","text":"function run_simulation!(network,n_spikes::Integer;t_start::Float64=0.0)\n  t_now = t_start\n  for _ in 1:n_spikes\n    t_now = H.dynamics_step!(t_now,network)\n  end\n  return t_now\nend\n\nfunction compute_weight_update(hvec::Vector{R},plasticity_rule;\n    wval = 1000.0,\n    n_spikes::Integer=80_000,τker::Float64=50E-3) where R<:Real\n  ps,tr = H.population_state_exp_and_trace(2,τker)\n  wmat = [0.0 wval; wval 0.0]\n  conn = H.ConnectionNonInteracting(wmat,plasticity_rule)\n  pop = H.PopulationExpKernel(ps,hvec,(conn,ps))\n  H.set_initial_rates!(pop,hvec)\n  rec = H.RecFullTrain(n_spikes+1,1)\n  netw = H.RecurrentNetworkExpKernel(pop,rec)\n  t_end = run_simulation!(netw,n_spikes)\n  recc = H.get_content(rec)\n  rates = H.numerical_rates(recc,2,t_end;pop_idx=1)\n  ΔW1 = (conn.weights[2,1] - wval) / t_end\n  ΔW2 = (conn.weights[1,2] - wval) / t_end\n  ΔW_avg = mean([ΔW1,ΔW2])\n  return (ΔW1=ΔW1,ΔW2 = ΔW2,ΔW_avg = ΔW_avg,rates = rates)\nend","category":"page"},{"location":"plasticity_STDP_ratecompare/#Start-with-Vogels-et-al.-2011","page":"Comparison of STDP rules in the rate-dominated regime","title":"Start with Vogels et al. 2011","text":"","category":"section"},{"location":"plasticity_STDP_ratecompare/","page":"Comparison of STDP rules in the rate-dominated regime","title":"Comparison of STDP rules in the rate-dominated regime","text":"The average change of weight should be $ B r{\\text{pre}}  r{\\text{post}} - \\eta\\, \\alpha\\,r{\\text{pre}} Where the area under the curve  B is B = 2 eta tau  and \\alpha = 2 r{\\text{targ}}\\, \\tau$.","category":"page"},{"location":"plasticity_STDP_ratecompare/","page":"Comparison of STDP rules in the rate-dominated regime","title":"Comparison of STDP rules in the rate-dominated regime","text":"Putting them together we get:","category":"page"},{"location":"plasticity_STDP_ratecompare/","page":"Comparison of STDP rules in the rate-dominated regime","title":"Comparison of STDP rules in the rate-dominated regime","text":"Delta W = 2etatau  r_textpre  (r_textpost -  r_texttarg)","category":"page"},{"location":"plasticity_STDP_ratecompare/","page":"Comparison of STDP rules in the rate-dominated regime","title":"Comparison of STDP rules in the rate-dominated regime","text":"As expected, the weight is tracking the difference between the target rate and the actual postsynaptic rate.","category":"page"},{"location":"plasticity_STDP_ratecompare/","page":"Comparison of STDP rules in the rate-dominated regime","title":"Comparison of STDP rules in the rate-dominated regime","text":"function analyticΔW(plast::H.PlasticityInhibitory,\n    rpre::Real,rpost::Real)\n  rtarg = 0.5*plast.α/plast.τ\n  return 2.0*plast.η*plast.τ*rpre*(rpost-rtarg)\nend\n\nfunction do_test_for_vogels(n::Integer;n_spikes::Integer=100_000)\n  rpres = rand(Uniform(20.0,50.0),n)\n  rposts = rand(Uniform(20.0,50.0),n)\n  rtargs = rand(Uniform(10.0,80.0),n)\n  τs = rand(Uniform(0.1,0.5),n)\n  η = 1E-8\n  anΔWs = Vector{Float64}(undef,n)\n  numΔWs = similar(anΔWs)\n  for k in 1:n\n    plast = H.PlasticityInhibitory(τs[k],η,2,2;r_target=rtargs[k])\n    anΔWs[k] = analyticΔW(plast,rpres[k],rposts[k])\n    numΔWs[k] = compute_weight_update([rpres[k],rposts[k]],plast;\n      wval=1E4,\n      n_spikes=n_spikes).ΔW1\n  end\n  anΔWs ./= η\n  numΔWs ./= η\n  return (anΔWs=anΔWs,numΔWs=numΔWs)\nend\n\n\nout = do_test_for_vogels(80)\n_ = let plt = plotvs(out.anΔWs,out.numΔWs)\n  xlabel!(plt,\"analytic ΔW\")\n  ylabel!(plt,\"numerical ΔW\")\n  plt\nend","category":"page"},{"location":"plasticity_STDP_ratecompare/#Now-symmetric-and-antisymmetric-STDPX-rules","page":"Comparison of STDP rules in the rate-dominated regime","title":"Now symmetric and antisymmetric STDPX rules","text":"","category":"section"},{"location":"plasticity_STDP_ratecompare/","page":"Comparison of STDP rules in the rate-dominated regime","title":"Comparison of STDP rules in the rate-dominated regime","text":"These are expanded versions of STDP that contain both rate-dependent and correlation-dependent terms. Here we ignore the latter.","category":"page"},{"location":"plasticity_STDP_ratecompare/","page":"Comparison of STDP rules in the rate-dominated regime","title":"Comparison of STDP rules in the rate-dominated regime","text":"Delta W =  A  left(  alpha_textpre  r_textpre + alpha_textpost  r_textpost +\n B  r_textpre  r_textpost right)","category":"page"},{"location":"plasticity_STDP_ratecompare/","page":"Comparison of STDP rules in the rate-dominated regime","title":"Comparison of STDP rules in the rate-dominated regime","text":"With $ B= 2\\;(1+\\theta)$ for symmetric   and $ B = (1+\\theta)$ for antisymmetric.","category":"page"},{"location":"plasticity_STDP_ratecompare/","page":"Comparison of STDP rules in the rate-dominated regime","title":"Comparison of STDP rules in the rate-dominated regime","text":"function analyticΔW(plast::H.PlasticitySymmetricSTDPX,\n    rpre::Real,rpost::Real)\n  B = 2.0*(1.0+plast.θ)\n  return plast.A * (plast.αpre*rpre + plast.αpost*rpost + B*rpre*rpost)\nend\n\nfunction analyticΔW(plast::H.PlasticityAsymmetricX,\n    rpre::Real,rpost::Real)\n  B = (1.0+plast.θ) # only difference with symmetric\n  return plast.A * (plast.αpre*rpre + plast.αpost*rpost + B*rpre*rpost)\nend\n\nfunction do_test_for_symmetricX(n::Integer;n_spikes::Integer=100_000)\n  rpres = rand(Uniform(20.0,50.0),n)\n  rposts = rand(Uniform(20.0,50.0),n)\n  A = 1E-6\n  thetas = rand(Uniform(-1.0,0.0),n)\n  τs = rand(Uniform(0.1,0.5),n)\n  gammas = rand(Uniform(1.5,20.0),n)\n  αpres = rand(Uniform(-3.0,3.0),n)\n  αposts = rand(Uniform(-3.0,3.0),n)\n  anΔWs = Vector{Float64}(undef,n)\n  numΔWs = similar(anΔWs)\n  for k in 1:n\n    plast = H.PlasticitySymmetricSTDPX(A,thetas[k],τs[k],gammas[k],αpres[k],αposts[k],2,2)\n    anΔWs[k] = analyticΔW(plast,rpres[k],rposts[k])\n    numΔWs[k] = compute_weight_update([rpres[k],rposts[k]],plast;\n      wval=1E4,\n      n_spikes=n_spikes).ΔW1\n  end\n  anΔWs ./= A\n  numΔWs ./= A\n  return (anΔWs=anΔWs,numΔWs=numΔWs)\nend\n\n\nout = do_test_for_symmetricX(80)\n_ = let plt = plotvs(out.anΔWs,out.numΔWs)\n  xlabel!(plt,\"analytic ΔW\")\n  ylabel!(plt,\"numerical ΔW\")\n  plt\nend","category":"page"},{"location":"plasticity_STDP_ratecompare/","page":"Comparison of STDP rules in the rate-dominated regime","title":"Comparison of STDP rules in the rate-dominated regime","text":"And the antisymmetric one. The function is the same, except for plasticity type But γ now can also be less than 1.","category":"page"},{"location":"plasticity_STDP_ratecompare/","page":"Comparison of STDP rules in the rate-dominated regime","title":"Comparison of STDP rules in the rate-dominated regime","text":"function do_test_for_asymmetricX(n::Integer;n_spikes::Integer=100_000)\n  rpres = rand(Uniform(20.0,50.0),n)\n  rposts = rand(Uniform(20.0,50.0),n)\n  A = 1E-6\n  thetas = rand(Uniform(-1.0,0.0),n)\n  τs = rand(Uniform(0.1,0.5),n)\n  gammas = rand(Uniform(0.1,5.0),n)\n  αpres = rand(Uniform(-3.0,3.0),n)\n  αposts = rand(Uniform(-3.0,3.0),n)\n  anΔWs = Vector{Float64}(undef,n)\n  numΔWs = similar(anΔWs)\n  for k in 1:n\n    plast = H.PlasticityAsymmetricX(A,thetas[k],τs[k],gammas[k],αpres[k],αposts[k],2,2)\n    anΔWs[k] = analyticΔW(plast,rpres[k],rposts[k])\n    numΔWs[k] = compute_weight_update([rpres[k],rposts[k]],plast;\n      wval=1E4,\n      n_spikes=n_spikes).ΔW1\n  end\n  anΔWs ./= A\n  numΔWs ./= A\n  return (anΔWs=anΔWs,numΔWs=numΔWs)\nend\n\nout = do_test_for_asymmetricX(80)\n_ = let plt = plotvs(out.anΔWs,out.numΔWs)\n  xlabel!(plt,\"analytic ΔW\")\n  ylabel!(plt,\"numerical ΔW\")\n  plt\nend\n\n#=\n# Now symmetric and antisymmetric generalized STDP rules with leak terms\n\nThese rules are simular to the above, but contain and additional (constant) leak term.\n\nAlso, I slightly changed the parametrization, because.\n\n```math\n\\Delta W =  Azero \\; \\left( \\alpha_{0} +  \\alpha_{\\text{pre}} \\, r_{\\text{pre}} + \\alpha_{\\text{post}} \\, r_{\\text{post}} +\n B \\, r_{\\text{pre}} \\, r_{\\text{post}} \\right)\n```\nWith $B = (Aplus+Aminus)$ for both symmetric and antisymmetric.\nSo it's really the same equation for both.\n=#\n\n\nfunction analyticΔW(plast::Union{H.PlasticitySymmetricSTDPGL,H.PlasticityAsymmetricSTDPGL},\n    rpre::Real,rpost::Real)\n  B = plast.Aplus + plast.Aminus\n  return plast.Azero * (plast.αzero + plast.αpre*rpre + plast.αpost*rpost + B*rpre*rpost)\nend\n\nfunction do_test_for_symmetricGL(n::Integer;n_spikes::Integer=100_000)\n  rpres = rand(Uniform(20.0,50.0),n)\n  rposts = rand(Uniform(20.0,50.0),n)\n  Azero = 1E-6\n  Aplusses = rand(Uniform(0.,0.3),n)\n  Aminuses = rand(Uniform(-0.3,0.),n)\n  τs = rand(Uniform(0.1,0.5),n)\n  gammas = rand(Uniform(1.1,20.0),n)\n  αzeros = rand(Uniform(-5.0,5.0),n)\n  αpres = rand(Uniform(-3.0,3.0),n)\n  αposts = rand(Uniform(-3.0,3.0),n)\n  anΔWs = Vector{Float64}(undef,n)\n  numΔWs = similar(anΔWs)\n  for k in 1:n\n    plast = H.PlasticitySymmetricSTDPGL(Azero,Aplusses[k],Aminuses[k],\n      τs[k],gammas[k],αzeros[k],αpres[k],αposts[k],2,2)\n    anΔWs[k] = analyticΔW(plast,rpres[k],rposts[k])\n    numΔWs[k] = compute_weight_update([rpres[k],rposts[k]],plast;\n      wval=1E4,\n      n_spikes=n_spikes).ΔW1\n  end\n  anΔWs ./= Azero\n  numΔWs ./= Azero\n  return (anΔWs=anΔWs,numΔWs=numΔWs)\nend\n\nout = do_test_for_symmetricGL(80)\n_ = let plt = plotvs(out.anΔWs,out.numΔWs)\n  xlabel!(plt,\"analytic ΔW\")\n  ylabel!(plt,\"numerical ΔW\")\n  plt\nend","category":"page"},{"location":"plasticity_STDP_ratecompare/","page":"Comparison of STDP rules in the rate-dominated regime","title":"Comparison of STDP rules in the rate-dominated regime","text":"","category":"page"},{"location":"plasticity_STDP_ratecompare/","page":"Comparison of STDP rules in the rate-dominated regime","title":"Comparison of STDP rules in the rate-dominated regime","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Hawkes-Processes-Simulator","page":"Home","title":"Hawkes Processes Simulator","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nThe documentation is still missing. Please see the \"examples\" section for usage.","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simple case: 1D and 2D with exponential kernel\n1D Hawkes process with a delayed kernel\nShow that rate in Hawkes is equivalent to linear network, in a 2D model\nPlasticity, pairwise STDP and triplet-based\nPlasticity, rate-dependent STDP\nPlasticity, match rate-components of different STDP rules","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#HawkesSimulator.bin_spikes-Union{Tuple{R}, Tuple{Vector{R}, R, R}} where R","page":"Home","title":"HawkesSimulator.bin_spikes","text":"bin_spikes(Y::Vector{R},dt::R,Tend::R;Tstart::R=0.0) where R\n\nArguments\n\nY::Vector{<:Real} : vector of spike times\ndt::Real : time bin size\nTend::Real : end time for the raster\n\nOptional argument\n\nTstart::Real=0.0 : start time for the raster\n\nReturns\n\nbinned_spikes::Vector{<:Integer} : binned_spikes[k] is the number of spikes that occur    in the timebin k  (i.e. between Tstart + (k-1)*dt and Tstart + k*dt)\n\n\n\n\n\n","category":"method"},{"location":"#HawkesSimulator.draw_spike_raster-Union{Tuple{C}, Tuple{Vector{Vector{Float64}}, Real, Real}} where C<:ColorTypes.Color","page":"Home","title":"HawkesSimulator.draw_spike_raster","text":"drawspikeraster(trains::Vector{Vector{Float64}},       dt::Real,Tend::Real;       Tstart::Real=0.0,       spikesize::Integer = 5,       spikeseparator::Integer = 1,       backgroundcolor::Color=RGB(1.,1.,1.),       spikecolors::Union{C,Vector{C}}=RGB(0.,0.0,0.0),       max_size::Real=1E4) where C<:Color\n\nDraws a matrix that contains the raster plot of the spike train.\n\nArguments\n\nTrains :  Vector of spike trains. The order of the vector corresponds to  the order of the plot. First element is at the top, second is second row, etc.\ndt : time interval representing one horizontal pixel  \nTend : final time to be considered\n\nOptional arguments\n\nTstart::Real : starting time\nspike_size::Integer : heigh of spike (in pixels)\nspike_separator::Integer : space between spikes, and vertical padding\nbackground_color::Color : self-explanatory\nspike_colors::Union{Color,Vector{Color}} : if a single color, color of all spikes, if vector of colors,   color for each neuron (length should be same as number of neurons)\nmax_size::Integer : throws an error if image is larger than this number (in pixels)\n\nReturns\n\nraster_matrix::Matrix{Color} you can save it as a png file\n\n\n\n\n\n","category":"method"},{"location":"#HawkesSimulator.dynamics_step_singlepopulation!-Tuple{Real, HawkesSimulator.RecurrentNetwork}","page":"Home","title":"HawkesSimulator.dynamics_step_singlepopulation!","text":"dynamics_step_singlepopulation!(t_now::Real,ntw::RecurrentNetwork)\n\nIterates a one-population network up until its next spike time. This is done by computing a next spike proposal for each neuron, and then picking the one that happens sooner. This spike is then added to the  spiketrain for that neuron. The fundtion returns the new current time of the simulation.\n\nFor long simulations, this functions should be called jointly with  flush_trains!. Otherwise the spike trains will keep growing, making the  propagation of signals extremely cumbersome.\n\nArguments\n\nt_now - Current time of the simulation\nntw   - The network\n\nReturns\n\nt_now_new - the new current time of the simulation\n\n\n\n\n\n","category":"method"},{"location":"#HawkesSimulator.flush_trains!-Tuple{HawkesSimulator.PopulationState, Real}","page":"Home","title":"HawkesSimulator.flush_trains!","text":"flush_trains!(ps::PopulationState,Ttrigger::Real;\n    Tflush::Union{Real,Nothing}=nothing)\n\nSpike history is spiketimes that do not interact with the kernel (because too old)         This function compares most recent spike with spike history, if enough time has passed   (measured by Ttrigger) it flushes the spiketrain up to Tflush into the history.\n\n\n\n\n\n","category":"method"},{"location":"#HawkesSimulator.get_trains-Tuple{Union{HawkesSimulator.RecFullTrainContent, HawkesSimulator.RecFullTrain}}","page":"Home","title":"HawkesSimulator.get_trains","text":"function gettrains(rec::RecFullTrain{N};        Nneus::Integer = 0,       popidx::Integer = 1) where N\n\nRead full recorded train from the population selected  by pop_idx (default 1).\n\n\n\n\n\n","category":"method"},{"location":"#HawkesSimulator.numerical_rates-Tuple{Union{HawkesSimulator.RecFullTrainContent, HawkesSimulator.RecFullTrain}, Integer, Real}","page":"Home","title":"HawkesSimulator.numerical_rates","text":"numericalrates(spikesrecorder,Nneus,Tend;pop_idx=1,Tstart=0.0)\n\nReturns the numerical rates of the neurons in the population pop_idx    that has been recorded through spikes_recorder (a RecFullTrain or a    RecFullTrainContent object). The rates are computed in the time interval    [Tstart,Tend] and are returned as a vector of length Nneus.\n\n\n\n\n\n","category":"method"},{"location":"#HawkesSimulator.warmup_step!-Tuple{Real, HawkesSimulator.RecurrentNetwork, Union{Vector{Vector{Float64}}, Vector{Float64}}}","page":"Home","title":"HawkesSimulator.warmup_step!","text":"warmupstep!(tnow::Real,ntw::RecurrentNetwork,     warmuprates::Union{Vector{Float64},Vector{Vector{Float64}}}) -> tend\n\nIn the warmup phase, all neurons fire as independent Poisson process  with a rate set by warmup_rates.   This is useful to quick-start the network, or set itinitial conditions that are far from the stable point.\n\nArguments\n\nt_now - current time\nntw  - the network (warning: weights and kernels are entirely ignored here)\nwarmup_rates - the desired stationary rates. In a one-population network,   it is a vector with the desired rates. In a multi-population network,   is a collection of vectors, where each vector refers to one population.\n\n\n\n\n\n","category":"method"},{"location":"hawkes_vs_2D_linear/#Compares-a-2D-Hawekes-process-to-a-2D-linear-system","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"","category":"section"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"In this example, I show that the mean rates in a 2D Hawes process perfectly match the mean rates of a 2D rate model.","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"I use exponential synaptic kernels (but it is valid for any kernel, since the kernel shape does not influence the mean rate)","category":"page"},{"location":"hawkes_vs_2D_linear/#Initialization","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Initialization","text":"","category":"section"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"using LinearAlgebra,Statistics,StatsBase,Distributions\nusing Plots,NamedColors ; theme(:default)\nusing FFTW\n\nusing ProgressMeter\nusing Random\nRandom.seed!(0)\n\nusing HawkesSimulator; const global H = HawkesSimulator\n\nfunction onedmat(x::Real)\n  return cat(x;dims=2)\nend;\nnothing #hide","category":"page"},{"location":"hawkes_vs_2D_linear/#Rate-Model","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Rate Model","text":"","category":"section"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"function iofunction(v::R,_v0::R,_α::R) where R<:Real\n  return max(_α*(v-_v0),zero(R))\nend\nfunction iofunction_inv(r::R,_v0::R,_α::R) where R<:Real\n  return max(zero(R),r/_α+_v0)\nend\n\nconst v0 = -70.0 # -70\nconst α = 0.03 # 0.3\nconst taus = [20.0, 10.0].*1E-3\nconst weights = [1.25 -0.65 ; 1.2 -0.5]\nconst input = [20.0, 50.0]\nconst dt = 0.01E-3\nconst Ttot = 1.0\nconst taus_hawk = [3.0,3.0];\nnothing #hide","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"Let's plot the activation function","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"theplot = let vs = range(-90,50.,length=150)\n  rs = @. iofunction(vs,v0,α)\n  plot(vs,rs;linewidth=2,leg=false,xlabel=\"voltage (mV)\",ylabel=\"rate (Hz)\",color=:black)\nend;\nplot(theplot)","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"I run the rate model by Euler integration, with timesteps of 0.01 ms (the variable dt)","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"function euler_dv(v::Vector{R},_weights::Matrix{R},_input::Vector{R},\n    _taus::Vector{R},_v0::R,_α::R) where R<:Real\n  r = @. iofunction(v,_v0,_α)\n  return (.-v .+ (_weights*r) .+ _input) ./ _taus\nend\n\nfunction run_2D_network()\n  v_start_e,v_start_i = 0.0,0.0\n  times = range(0.0,Ttot;step=dt)\n  ntimes = length(times)\n  rates = Matrix{Float64}(undef,2,ntimes)\n  v = [v_start_e,v_start_i]\n  for tt in eachindex(times)\n    rates[:,tt] = iofunction.(v,v0,α)\n    dv = euler_dv(v,weights,input,taus,v0,α)\n    v += dv*dt\n  end\n  return times,rates\nend;\n\n\nruntimes,runrates = run_2D_network();\nnothing #hide","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"rates and times have been stored in the variables above!","category":"page"},{"location":"hawkes_vs_2D_linear/#Hawkes-process","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Hawkes process","text":"","category":"section"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"To define the Hawkes process, I need to find equivalent rates and currents that account for the input-output function that I used.","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"weights_equiv = @. abs(α^2*weights)\ninputs_equiv =  α .* (input .- (α .* weights+I)*fill(v0,2))\nps_e,tr_e = H.population_state_exp_and_trace(1,taus_hawk[1])\nps_i,tr_i = H.population_state_exp_and_trace_inhibitory(1,taus_hawk[2])","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"define conenctions","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"conn_ee = H.ConnectionExpKernel(onedmat(weights_equiv[1,1]),tr_e)\nconn_ie = H.ConnectionExpKernel(onedmat(weights_equiv[2,1]),tr_e)\nconn_ei = H.ConnectionExpKernel(onedmat(weights_equiv[1,2]),tr_i)\nconn_ii = H.ConnectionExpKernel(onedmat(weights_equiv[2,2]),tr_i);\nnothing #hide","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"define populations","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"pop_e = H.PopulationExpKernel(ps_e,inputs_equiv[1:1],(conn_ee,ps_e),(conn_ei,ps_i) )\npop_i = H.PopulationExpKernel(ps_i,inputs_equiv[2:2],(conn_ie,ps_e),(conn_ii,ps_i) );\nnothing #hide","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"define recorder: I record all spiketimes, although I only need the rate","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"nrec = 10_010\nrec = H.RecFullTrain(nrec,2);\nnothing #hide","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"define network:","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"netw = H.RecurrentNetworkExpKernel((pop_e,pop_i),(rec,));\nnothing #hide","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"run network","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"function run_simulation!(network,num_spikes)\n  t_now = 0.0\n  H.reset!(network) # clear spike trains etc\n  for _ in 1:num_spikes\n    t_now = H.dynamics_step!(t_now,network)\n  end\n  return t_now\nend\n\nnspikes = nrec - 1\nt_end=run_simulation!(netw,nspikes)\n\nrecc = H.get_content(rec)\nrates_e = H.numerical_rates(recc,1,t_end;pop_idx=1)\nrates_i = H.numerical_rates(recc,1,t_end;pop_idx=2)","category":"page"},{"location":"hawkes_vs_2D_linear/#Result:-compare-the-rate-in-the-two-sytems","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Result: compare the rate in the two sytems","text":"","category":"section"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"@info \"final rates are $(round.(runrates[:,end];digits=2))\"\n@info \"Hawkes final rates are $(round.(first.((rates_e,rates_i));digits=2))\"","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"THE END","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"","category":"page"},{"location":"hawkes_vs_2D_linear/","page":"Compares a 2D Hawekes process to a 2D linear system","title":"Compares a 2D Hawekes process to a 2D linear system","text":"This page was generated using Literate.jl.","category":"page"}]
}
