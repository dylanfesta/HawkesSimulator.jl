<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Spiking-based plasticity rules for two neurons · HawkesSimulator.jl</title><meta name="title" content="Spiking-based plasticity rules for two neurons · HawkesSimulator.jl"/><meta property="og:title" content="Spiking-based plasticity rules for two neurons · HawkesSimulator.jl"/><meta property="twitter:title" content="Spiking-based plasticity rules for two neurons · HawkesSimulator.jl"/><meta name="description" content="Documentation for HawkesSimulator.jl."/><meta property="og:description" content="Documentation for HawkesSimulator.jl."/><meta property="twitter:description" content="Documentation for HawkesSimulator.jl."/><meta property="og:url" content="https://dylanfesta.github.io/HawkesSimulator.jl/plasticity_STDP/"/><meta property="twitter:url" content="https://dylanfesta.github.io/HawkesSimulator.jl/plasticity_STDP/"/><link rel="canonical" href="https://dylanfesta.github.io/HawkesSimulator.jl/plasticity_STDP/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">HawkesSimulator.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Spiking-based plasticity rules for two neurons</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Spiking-based plasticity rules for two neurons</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/dylanfesta/HawkesSimulator.jl/blob/master/examples/plasticity_STDP.jl" title="View source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Spiking-based-plasticity-rules-for-two-neurons"><a class="docs-heading-anchor" href="#Spiking-based-plasticity-rules-for-two-neurons">Spiking-based plasticity rules for two neurons</a><a id="Spiking-based-plasticity-rules-for-two-neurons-1"></a><a class="docs-heading-anchor-permalink" href="#Spiking-based-plasticity-rules-for-two-neurons" title="Permalink"></a></h1><p>In this example, I show the effects of plasticity rules on a single pre-post connection between the two neurons. The neural activity is entirely regulated from the outside (e.g. the neurons do not interact through their weights). This is to better illustrate plasticity rules in their simplest form.</p><p>I also consider analytic results for purely Poisson firing (uncorrelated).</p><h1 id="Initialization"><a class="docs-heading-anchor" href="#Initialization">Initialization</a><a id="Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization" title="Permalink"></a></h1><pre><code class="language-julia hljs">using LinearAlgebra,Statistics,StatsBase,Distributions
using Plots,NamedColors,LaTeXStrings ; theme(:default) ; gr()

using InvertedIndices
using ProgressMeter
using Random
Random.seed!(0)

using HawkesSimulator; const global H = HawkesSimulator</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">HawkesSimulator</code></pre><h1 id="Part-1:-Poisson-processes"><a class="docs-heading-anchor" href="#Part-1:-Poisson-processes">Part 1: Poisson processes</a><a id="Part-1:-Poisson-processes-1"></a><a class="docs-heading-anchor-permalink" href="#Part-1:-Poisson-processes" title="Permalink"></a></h1><p>Here the neurons are uncorrelated Poisson processes.</p><p>The goal is to emphasize the rate-dependent part of plasticity, comparing pairwise STDP to triplet STDP</p><h2 id="Plasticity:-positive-biased-STPD-rule"><a class="docs-heading-anchor" href="#Plasticity:-positive-biased-STPD-rule">Plasticity: positive biased STPD rule</a><a id="Plasticity:-positive-biased-STPD-rule-1"></a><a class="docs-heading-anchor-permalink" href="#Plasticity:-positive-biased-STPD-rule" title="Permalink"></a></h2><p>Here the weight change will depent linearly on pre and post rate.</p><h3 id="Functions-that-generate-spiketrains,-plasticity,-population,-etc"><a class="docs-heading-anchor" href="#Functions-that-generate-spiketrains,-plasticity,-population,-etc">Functions that generate spiketrains, plasticity, population, etc</a><a id="Functions-that-generate-spiketrains,-plasticity,-population,-etc-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-that-generate-spiketrains,-plasticity,-population,-etc" title="Permalink"></a></h3><p>this one generates the connection object</p><pre><code class="language-julia hljs">function do_2by2_connection(τplus::R,A2plus::R,τminus::R,A2minus::R;w_start::R=100.0) where R
  N=2
  _plast = HawkesSimulator.PairSTDP(τplus,τminus,A2plus,A2minus,N,N)
  W = fill(w_start,N,N)
  W[diagind(W)] .= 0.0
  return H.ConnectionDenseWeights(W,_plast)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">do_2by2_connection (generic function with 1 method)</code></pre><p>this one generates spike trains, a network object, a weight recorder. It requres a connection</p><pre><code class="language-julia hljs">function population_trains(rate1::R,rate2::R,conn::H.Connection;
    ttot::R=5_000.0,krec::Integer=400) where R
  N = 2
  trains =[ H.make_poisson_samples(rate1,ttot),
             H.make_poisson_samples(rate2,ttot) ]
  _ps = H.PopulationState(H.InputUnit(H.SGTrains(trains)),N)
  pop = H.PopulationInputTestWeights(_ps,conn)
  recweights = H.RecTheseWeights(conn.weights,ttot/krec,ttot)
  ntw = H.RecurrentNetworkExpKernel(pop,recweights)
  return recweights,ntw
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">population_trains (generic function with 1 method)</code></pre><p>this put the previous two together</p><pre><code class="language-julia hljs">function plastic_two_neurons(τplus::R,A2plus::R,τminus::R,A2minus::R,rate1::R,rate2::R;
    w_start::R=100.0,ttot::R=5_000.,krec=400) where R
  conn = do_2by2_connection(τplus,A2plus,τminus,A2minus;w_start=w_start)
  recweights,ntw = population_trains( rate1,rate2,conn; ttot=ttot,krec=krec)
  return conn,recweights,ntw
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">plastic_two_neurons (generic function with 1 method)</code></pre><p>runs the network</p><pre><code class="language-julia hljs">function run_network01(ntw,conn,recweights,ttot)
  H.reset!(ntw)
  H.reset!(recweights)
  w_start = copy(conn.weights)
  _T=ttot-0.1
  t_now = 0.0
  prog = Progress(ceil(Integer,_T);dt=5)
  while t_now &lt;= _T
    t_now = H.dynamics_step_singlepopulation!(t_now,ntw)
    if t_now &gt; _T
      ProgressMeter.finish!(prog)
    else
      update!(prog,floor(Integer,t_now))
    end
  end
  w_end = copy(conn.weights)
  return w_start,w_end,t_now
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">run_network01 (generic function with 1 method)</code></pre><p>Utility functions to make nice plots</p><pre><code class="language-julia hljs">function mynormalize(mat::Matrix{&lt;:Real})
  _mi,_ma = extrema(mat)
  hasminus = _mi &lt; -1E-4
  if hasminus
    idxplus = mat .&gt; 0
    matnorm = similar(mat)
    matnorm[idxplus] = mat[idxplus] ./ _ma
    matnorm[Not(idxplus)] = mat[Not(idxplus)] ./ abs(_mi)
  else
    matnorm = mat ./ _ma
  end
  return hasminus,matnorm
end

function plot_nice_DW(r1::AbstractVector{R},r2::AbstractVector{R},DW::Matrix{R}) where R
  rh = 0.5(r1[2]-r1[1])
  colorh = colorant&quot;#F47D23&quot;
  colorm = colorant&quot;white&quot;
  colorl = colorant&quot;#147ABF&quot;
  hasminus = minimum(DW) &lt; -1E-2
  if hasminus
    _min,_max = extrema(DW)
    _mid = -_min/(_max-_min)
    myc = cgrad([colorl,colorm,colorh],[0,_mid,1.0])
  else
    myc = cgrad([colorm,colorh],[0,1.0])
  end
  _lims = (rh,rh+r1[end])
  return heatmap(r1,r2,DW;
    xlabel = L&quot;r_{\mathrm{post}}&quot;,
    ylabel = L&quot;r_{\mathrm{pre}}&quot;,
    xlims=_lims,ylims=_lims,
    ratio=1, color=myc)
end
function plot_nice_DW_normed(r1::AbstractVector{R},r2::AbstractVector{R},DW::Matrix{R}) where R
  colorh = colorant&quot;#F47D23&quot;
  colorm = colorant&quot;white&quot;
  colorl = colorant&quot;#147ABF&quot;
  hasminus,DWn = mynormalize(DW)
  if hasminus
    myc = cgrad([colorl,colorm,colorh],[-1,0,1.0])
  else
    myc = cgrad([colorm,colorh],[0,1.0])
  end
  rh = 0.5(r1[2]-r1[1])
  _lims = (rh,rh+r1[end])
  return heatmap(r1,r2,DWn;
    xlabel = L&quot;r_{\mathrm{post}}&quot;,
    ylabel = L&quot;r_{\mathrm{pre}}&quot;,
    xlims=_lims,ylims=_lims,
    ratio=1,
    color=myc)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">plot_nice_DW_normed (generic function with 1 method)</code></pre><h3 id="Run-numerical-simulation-for-specific-parameters"><a class="docs-heading-anchor" href="#Run-numerical-simulation-for-specific-parameters">Run numerical simulation for specific parameters</a><a id="Run-numerical-simulation-for-specific-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Run-numerical-simulation-for-specific-parameters" title="Permalink"></a></h3><pre><code class="language-julia hljs">const plast_eps = 1E-4
const A2plus = 1.0 * plast_eps
const τplus = 0.5
const A2minus = -0.7 * plast_eps
const τminus = 0.69
const rate1 = 10.
const rate2 = 15.0
const ttot = 1_000.0</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1000.0</code></pre><p>plot weight change in time</p><pre><code class="language-julia hljs">theplot = let  (conn,recweights,ntw) =
    plastic_two_neurons(τplus,A2plus,τminus,A2minus,rate1,rate2;ttot=ttot),
  (w_start,w_end,t_end) = run_network01(ntw,conn,recweights,ttot)
  plt = plot(size=(300,200))
  ws12 = [_w[1,2] for _w in recweights.weights]
  ws21 = [_w[2,1] for _w in recweights.weights]
  wtimes = recweights.times
  plot!(plt,wtimes,ws12;label=L&quot;$w_{12}$&quot;,linewidth=2)
  plot!(plt,wtimes,ws21;label=L&quot;$w_{21}$&quot;,linewidth=2)
  plot!(plt,xlabel=&quot;time (s)&quot;,ylabel=&quot;weight&quot;,leg=:topleft,
    title=&quot;&quot;)
  plt
end
plot(theplot)</code></pre><img src="a8da8750.svg" alt="Example block output"/><p>The STDP rule is potentiation dominated, so the weights grow linearly.</p><h3 id="Run-numerical-simulation-for-varying-rates"><a class="docs-heading-anchor" href="#Run-numerical-simulation-for-varying-rates">Run numerical simulation for varying rates</a><a id="Run-numerical-simulation-for-varying-rates-1"></a><a class="docs-heading-anchor-permalink" href="#Run-numerical-simulation-for-varying-rates" title="Permalink"></a></h3><pre><code class="language-julia hljs">const nrates = 20
const rates1 = range(0.1,45.;length=nrates)
const rates2 = copy(rates1)
const DW12 = Matrix{Float64}(undef,nrates,nrates)

const plast_eps = 1E-4
const A2plus = 1.0 * plast_eps
const τplus = 0.5
const A2minus = -0.7 * plast_eps
const τminus = 0.69
const ttot = 1_000.0

@showprogress for ij in CartesianIndices(DW12)
  conn,recweights,ntw = plastic_two_neurons(τplus,A2plus,τminus,A2minus,
    rates1[ij[1]],rates2[ij[2]];ttot=ttot)
  (w_start,w_end,t_end) = run_network01(ntw,conn,recweights,ttot)
  DW12[ij] = w_end[1,2] - w_start[1,2]
end

plot_nice_DW(rates1,rates2,DW12)</code></pre><img src="65c575d2.svg" alt="Example block output"/><p>compare with analytic values</p><pre><code class="language-julia hljs">rates_an = range(0.1,45.;length=150)
DW12_analytic_dense = let c = A2plus*τplus + A2minus*τminus
  (c*ttot) .* (rates_an * rates_an&#39;)
end

theplot = let  c = A2plus*τplus + A2minus*τminus
  DW12_analytic = (c*ttot) .* (rates1 * rates2&#39;)
  plt = plot()
  scatter!(plt,DW12[:],DW12_analytic[:],color=:black)
  plot!(plt,identity,ratio=1,xlabel=&quot;numeric&quot;,ylabel=&quot;analytic&quot;,linestyle=:dash,linewidth=3,
    color=:yellow,leg=false)
end</code></pre><img src="9d6fc1e8.svg" alt="Example block output"/><p>show the analytic heatmap</p><pre><code class="language-julia hljs">plot_nice_DW_normed(rates_an,rates_an,DW12_analytic_dense)</code></pre><img src="b42a2642.svg" alt="Example block output"/><h2 id="Plasticity-:-triplet-STDP-with-usual-parameters"><a class="docs-heading-anchor" href="#Plasticity-:-triplet-STDP-with-usual-parameters">Plasticity : triplet STDP with usual parameters</a><a id="Plasticity-:-triplet-STDP-with-usual-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Plasticity-:-triplet-STDP-with-usual-parameters" title="Permalink"></a></h2><p>I will go straight to the part where I consider multiple rates</p><p>this one generates the connection object</p><pre><code class="language-julia hljs">function do_2by2_connection_triplets(τplus::R,A2plus::R,τminus::R,A2minus::R,
     τx::R,A3plus::R,τy::R,A3minus::R;w_start::R=100.0) where R
  N=2
  _plast = HawkesSimulator.PlasticityTriplets(τplus,τminus,τx,τy,A2plus,A3plus,A2minus,A3minus,N,N)
  W = fill(w_start,N,N)
  W[diagind(W)] .= 0.0
  return H.ConnectionDenseWeights(W,_plast)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">do_2by2_connection_triplets (generic function with 1 method)</code></pre><p>this put the previous two together</p><pre><code class="language-julia hljs">function plastic_two_neurons_triplets(τplus::R,A2plus::R,τminus::R,A2minus::R,
    τx::R,A3plus::R,τy::R,A3minus::R,rate1::R,rate2::R;
    w_start::R=100.0,ttot::R=5_000.,krec=400) where R
  conn = do_2by2_connection_triplets(τplus,A2plus,τminus,A2minus,τx,A3plus,τy,A3minus;w_start=w_start)
  recweights,ntw = population_trains( rate1,rate2,conn; ttot=ttot,krec=krec)
  return conn,recweights,ntw
end


const nrates = 20
const rates1 = range(0.1,45.;length=nrates)
const rates2 = copy(rates1)
const DW12 = Matrix{Float64}(undef,nrates,nrates)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">20×20 Matrix{Float64}:
 5.0e-324      2.122e-314    4.17327e-316  …  8.38726e-316    0.0
 2.122e-314    7.52834e-316  1.37105e-315     1.37106e-315    1.37251e-315
 8.25117e-316  1.37104e-315  8.48798e-314     0.0             0.0
 0.0           0.0           1.37103e-315     5.75116e-316    5.0e-324
 2.122e-314    0.0           1.37103e-315     9.02839e-316    1.37106e-315
 7.51125e-316  1.37104e-315  1.37103e-315  …  1.37106e-315    8.48798e-314
 1.37104e-315  8.48798e-314  1.37103e-315     1.19086e-316    1.37106e-315
 0.0           0.0           1.52784e-312     0.0             8.74e-322
 1.37104e-315  0.0           5.0e-324         6.36599e-314    8.31133e-316
 8.25347e-316  0.0           2.122e-314       0.0             8.96936e-316
 1.9098e-313   0.0           6.68971e-316  …  0.0             1.37106e-315
 1.37103e-315  1.50662e-312  0.0              0.0             8.48798e-314
 4.17327e-316  5.0e-324      2.122e-314       9.03598e-316    1.37106e-315
 1.37103e-315  2.122e-314    8.75487e-316     8.05e-322       8.48798e-314
 1.37103e-315  7.52834e-316  1.37105e-315     5.39068e-316    8.48798e-314
 1.5915e-312   0.0           0.0           …  9.84366e-317    5.6e-322
 0.0           2.122e-314    0.0              1.581e-320      8.31133e-316
 2.122e-314    6.68971e-316  1.37105e-315     1.03e-321       6.93599e-310
 7.51125e-316  1.37105e-315  8.48798e-314     7.39314e-316  NaN
 0.0           0.0           0.0              1.37251e-315    3.26e-322</code></pre><p>parameters considered as &quot;standard&quot; for triplet STDP rule</p><pre><code class="language-julia hljs">const plast_eps = 1E-3

const	A2plus  = 7.5E-7 *plast_eps
const	A2minus = -7.0   *plast_eps
const	A3plus  = 6.0    *plast_eps  # 9.3
const	A3minus = -0.23  *plast_eps

const τplus = 17E-3
const τminus = 34E-3
const τy = 101E-3
const τx = 125E-3</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.125</code></pre><p>run simulation for varying rates</p><pre><code class="language-julia hljs">@showprogress for ij in CartesianIndices(DW12)
  conn,recweights,ntw = plastic_two_neurons_triplets(τplus,A2plus,τminus,A2minus,
    τx,A3plus,τy,A3minus,
    rates1[ij[1]],rates2[ij[2]];ttot=ttot)
  (w_start,w_end,t_end) = run_network01(ntw,conn,recweights,ttot)
  DW12[ij] = w_end[1,2] - w_start[1,2]
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Progress:   2%|▊                                        |  ETA: 0:00:06Progress:   3%|█▎                                       |  ETA: 0:00:08Progress:   4%|█▌                                       |  ETA: 0:00:09Progress:   4%|█▉                                       |  ETA: 0:00:10Progress:   5%|██                                       |  ETA: 0:00:12Progress:  10%|████▏                                    |  ETA: 0:00:11Progress:  13%|█████▍                                   |  ETA: 0:00:10Progress:  14%|█████▊                                   |  ETA: 0:00:11Progress:  14%|██████                                   |  ETA: 0:00:11Progress:  15%|██████▏                                  |  ETA: 0:00:11Progress:  17%|███████▏                                 |  ETA: 0:00:10Progress:  18%|███████▌                                 |  ETA: 0:00:10Progress:  19%|███████▊                                 |  ETA: 0:00:10Progress:  19%|███████▉                                 |  ETA: 0:00:11Progress:  20%|████████▏                                |  ETA: 0:00:11Progress:  21%|████████▌                                |  ETA: 0:00:11Progress:  22%|████████▉                                |  ETA: 0:00:10Progress:  23%|█████████▍                               |  ETA: 0:00:10Progress:  24%|█████████▋                               |  ETA: 0:00:10Progress:  24%|█████████▉                               |  ETA: 0:00:10Progress:  24%|██████████                               |  ETA: 0:00:10Progress:  25%|██████████▎                              |  ETA: 0:00:11Progress:  26%|██████████▊                              |  ETA: 0:00:10Progress:  28%|███████████▎                             |  ETA: 0:00:10Progress:  28%|███████████▋                             |  ETA: 0:00:10Progress:  29%|███████████▊                             |  ETA: 0:00:10Progress:  29%|████████████                             |  ETA: 0:00:10Progress:  30%|████████████▎                            |  ETA: 0:00:10Progress:  30%|████████████▌                            |  ETA: 0:00:10Progress:  32%|█████████████                            |  ETA: 0:00:10Progress:  32%|█████████████▍                           |  ETA: 0:00:10Progress:  33%|█████████████▋                           |  ETA: 0:00:10Progress:  34%|█████████████▉                           |  ETA: 0:00:10Progress:  34%|██████████████                           |  ETA: 0:00:10Progress:  35%|██████████████▎                          |  ETA: 0:00:10Progress:  36%|██████████████▌                          |  ETA: 0:00:10Progress:  36%|███████████████                          |  ETA: 0:00:10Progress:  37%|███████████████▎                         |  ETA: 0:00:10Progress:  38%|███████████████▋                         |  ETA: 0:00:10Progress:  38%|███████████████▊                         |  ETA: 0:00:10Progress:  39%|████████████████                         |  ETA: 0:00:10Progress:  40%|████████████████▎                        |  ETA: 0:00:10Progress:  40%|████████████████▍                        |  ETA: 0:00:10Progress:  41%|████████████████▊                        |  ETA: 0:00:09Progress:  42%|█████████████████▏                       |  ETA: 0:00:09Progress:  42%|█████████████████▍                       |  ETA: 0:00:09Progress:  43%|█████████████████▋                       |  ETA: 0:00:09Progress:  44%|█████████████████▉                       |  ETA: 0:00:09Progress:  44%|██████████████████                       |  ETA: 0:00:09Progress:  44%|██████████████████▎                      |  ETA: 0:00:09Progress:  45%|██████████████████▌                      |  ETA: 0:00:09Progress:  46%|██████████████████▉                      |  ETA: 0:00:09Progress:  47%|███████████████████▏                     |  ETA: 0:00:09Progress:  48%|███████████████████▌                     |  ETA: 0:00:09Progress:  48%|███████████████████▋                     |  ETA: 0:00:09Progress:  48%|███████████████████▉                     |  ETA: 0:00:09Progress:  49%|████████████████████▏                    |  ETA: 0:00:09Progress:  50%|████████████████████▎                    |  ETA: 0:00:09Progress:  50%|████████████████████▌                    |  ETA: 0:00:09Progress:  51%|████████████████████▉                    |  ETA: 0:00:08Progress:  52%|█████████████████████▎                   |  ETA: 0:00:08Progress:  52%|█████████████████████▌                   |  ETA: 0:00:08Progress:  53%|█████████████████████▊                   |  ETA: 0:00:08Progress:  54%|█████████████████████▉                   |  ETA: 0:00:08Progress:  54%|██████████████████████▏                  |  ETA: 0:00:08Progress:  54%|██████████████████████▍                  |  ETA: 0:00:08Progress:  55%|██████████████████████▌                  |  ETA: 0:00:08Progress:  56%|███████████████████████                  |  ETA: 0:00:08Progress:  56%|███████████████████████▏                 |  ETA: 0:00:08Progress:  57%|███████████████████████▌                 |  ETA: 0:00:08Progress:  58%|███████████████████████▋                 |  ETA: 0:00:08Progress:  58%|███████████████████████▉                 |  ETA: 0:00:08Progress:  59%|████████████████████████▏                |  ETA: 0:00:07Progress:  59%|████████████████████████▎                |  ETA: 0:00:07Progress:  60%|████████████████████████▌                |  ETA: 0:00:07Progress:  60%|████████████████████████▊                |  ETA: 0:00:07Progress:  61%|█████████████████████████                |  ETA: 0:00:07Progress:  62%|█████████████████████████▍               |  ETA: 0:00:07Progress:  62%|█████████████████████████▌               |  ETA: 0:00:07Progress:  63%|█████████████████████████▊               |  ETA: 0:00:07Progress:  63%|█████████████████████████▉               |  ETA: 0:00:07Progress:  64%|██████████████████████████▏              |  ETA: 0:00:07Progress:  64%|██████████████████████████▍              |  ETA: 0:00:07Progress:  65%|██████████████████████████▌              |  ETA: 0:00:07Progress:  65%|██████████████████████████▋              |  ETA: 0:00:07Progress:  66%|███████████████████████████              |  ETA: 0:00:07Progress:  66%|███████████████████████████▎             |  ETA: 0:00:06Progress:  67%|███████████████████████████▌             |  ETA: 0:00:06Progress:  68%|███████████████████████████▋             |  ETA: 0:00:06Progress:  68%|███████████████████████████▉             |  ETA: 0:00:06Progress:  68%|████████████████████████████▏            |  ETA: 0:00:06Progress:  69%|████████████████████████████▎            |  ETA: 0:00:06Progress:  70%|████████████████████████████▌            |  ETA: 0:00:06Progress:  70%|████████████████████████████▊            |  ETA: 0:00:06Progress:  71%|█████████████████████████████            |  ETA: 0:00:06Progress:  72%|█████████████████████████████▍           |  ETA: 0:00:06Progress:  72%|█████████████████████████████▌           |  ETA: 0:00:06Progress:  72%|█████████████████████████████▊           |  ETA: 0:00:05Progress:  73%|█████████████████████████████▉           |  ETA: 0:00:05Progress:  74%|██████████████████████████████▏          |  ETA: 0:00:05Progress:  74%|██████████████████████████████▍          |  ETA: 0:00:05Progress:  74%|██████████████████████████████▌          |  ETA: 0:00:05Progress:  75%|██████████████████████████████▋          |  ETA: 0:00:05Progress:  75%|██████████████████████████████▉          |  ETA: 0:00:05Progress:  76%|███████████████████████████████          |  ETA: 0:00:05Progress:  76%|███████████████████████████████▍         |  ETA: 0:00:05Progress:  77%|███████████████████████████████▋         |  ETA: 0:00:05Progress:  78%|███████████████████████████████▊         |  ETA: 0:00:05Progress:  78%|████████████████████████████████         |  ETA: 0:00:04Progress:  78%|████████████████████████████████▏        |  ETA: 0:00:04Progress:  79%|████████████████████████████████▍        |  ETA: 0:00:04Progress:  80%|████████████████████████████████▋        |  ETA: 0:00:04Progress:  80%|████████████████████████████████▊        |  ETA: 0:00:04Progress:  80%|████████████████████████████████▉        |  ETA: 0:00:04Progress:  81%|█████████████████████████████████▏       |  ETA: 0:00:04Progress:  81%|█████████████████████████████████▎       |  ETA: 0:00:04Progress:  82%|█████████████████████████████████▌       |  ETA: 0:00:04Progress:  82%|█████████████████████████████████▊       |  ETA: 0:00:04Progress:  83%|█████████████████████████████████▉       |  ETA: 0:00:04Progress:  83%|██████████████████████████████████▏      |  ETA: 0:00:04Progress:  84%|██████████████████████████████████▍      |  ETA: 0:00:03Progress:  84%|██████████████████████████████████▌      |  ETA: 0:00:03Progress:  84%|██████████████████████████████████▋      |  ETA: 0:00:03Progress:  85%|██████████████████████████████████▉      |  ETA: 0:00:03Progress:  86%|███████████████████████████████████      |  ETA: 0:00:03Progress:  86%|███████████████████████████████████▎     |  ETA: 0:00:03Progress:  86%|███████████████████████████████████▌     |  ETA: 0:00:03Progress:  87%|███████████████████████████████████▋     |  ETA: 0:00:03Progress:  88%|███████████████████████████████████▉     |  ETA: 0:00:03Progress:  88%|████████████████████████████████████▏    |  ETA: 0:00:03Progress:  88%|████████████████████████████████████▎    |  ETA: 0:00:03Progress:  89%|████████████████████████████████████▌    |  ETA: 0:00:02Progress:  89%|████████████████████████████████████▋    |  ETA: 0:00:02Progress:  90%|████████████████████████████████████▊    |  ETA: 0:00:02Progress:  90%|████████████████████████████████████▉    |  ETA: 0:00:02Progress:  90%|█████████████████████████████████████▏   |  ETA: 0:00:02Progress:  91%|█████████████████████████████████████▎   |  ETA: 0:00:02Progress:  92%|█████████████████████████████████████▌   |  ETA: 0:00:02Progress:  92%|█████████████████████████████████████▊   |  ETA: 0:00:02Progress:  92%|█████████████████████████████████████▉   |  ETA: 0:00:02Progress:  93%|██████████████████████████████████████▏  |  ETA: 0:00:02Progress:  94%|██████████████████████████████████████▍  |  ETA: 0:00:01Progress:  94%|██████████████████████████████████████▌  |  ETA: 0:00:01Progress:  94%|██████████████████████████████████████▋  |  ETA: 0:00:01Progress:  94%|██████████████████████████████████████▊  |  ETA: 0:00:01Progress:  95%|██████████████████████████████████████▉  |  ETA: 0:00:01Progress:  95%|███████████████████████████████████████  |  ETA: 0:00:01Progress:  96%|███████████████████████████████████████▏ |  ETA: 0:00:01Progress:  96%|███████████████████████████████████████▍ |  ETA: 0:00:01Progress:  96%|███████████████████████████████████████▋ |  ETA: 0:00:01Progress:  97%|███████████████████████████████████████▊ |  ETA: 0:00:01Progress:  98%|████████████████████████████████████████ |  ETA: 0:00:01Progress:  98%|████████████████████████████████████████▏|  ETA: 0:00:00Progress:  98%|████████████████████████████████████████▍|  ETA: 0:00:00Progress:  99%|████████████████████████████████████████▌|  ETA: 0:00:00Progress:  99%|████████████████████████████████████████▊|  ETA: 0:00:00Progress: 100%|████████████████████████████████████████▊|  ETA: 0:00:00Progress: 100%|████████████████████████████████████████▉|  ETA: 0:00:00Progress: 100%|█████████████████████████████████████████| Time: 0:00:23</code></pre><p>show result</p><pre><code class="language-julia hljs">plot_nice_DW(rates1,rates2,DW12)</code></pre><img src="18c90c7c.svg" alt="Example block output"/><p>compare with analytics</p><p>compare with analytic values</p><pre><code class="language-julia hljs">rates_dense = range(0.1,45.;length=150)
DW12_analytic_dense = let r1r1 =  rates_dense * rates_dense&#39;
  r2r1 = (rates_dense.^2)*rates_dense&#39;
  r1r2 = rates_dense*(rates_dense.^2)&#39;
  c11 = A2plus*τplus + A2minus*τminus
  c12 = A3minus*τminus*τx
  c21 = A3plus*τplus*τy
  @. ttot * (c11*r1r1 + c12*r1r2 + c21*r2r1)
end

theplot = let r1r1 =  rates1 * rates2&#39;
  r2r1 = (rates1.^2)*rates2&#39;
  r1r2 = rates1*(rates2.^2)&#39;
  c11 = A2plus*τplus + A2minus*τminus
  c12 = A3minus*τminus*τx
  c21 = A3plus*τplus*τy
  DW12_analytic =  @. ttot * (c11*r1r1 + c12*r1r2 + c21*r2r1)
  plt = plot()
  scatter!(plt,DW12[:],DW12_analytic[:],color=:black)
  plot!(plt,identity,ratio=1,xlabel=&quot;numeric&quot;,ylabel=&quot;analytic&quot;,linestyle=:dash,linewidth=3,
    color=:yellow,leg=false)
end
plot(theplot)</code></pre><img src="5cc8921e.svg" alt="Example block output"/><p>show the analytic heatmap</p><pre><code class="language-julia hljs">plot_nice_DW_normed(rates_an,rates_an,DW12_analytic_dense)</code></pre><img src="70b737a6.svg" alt="Example block output"/><h1 id="Part-2-:-pairing-protocol"><a class="docs-heading-anchor" href="#Part-2-:-pairing-protocol">Part 2 : pairing protocol</a><a id="Part-2-:-pairing-protocol-1"></a><a class="docs-heading-anchor-permalink" href="#Part-2-:-pairing-protocol" title="Permalink"></a></h1><p>Here  neurons are forced to spike as in typical STDP experimental protocols. That is, they both fire at the same  rate, but with a time difference set to a certain <span>$\Delta t$</span>.</p><pre><code class="language-julia hljs">function post_pre_spiketrains(rate::R,Δt_ro::R,Ttot::R;
    tstart::R = 0.05) where R
  post = collect(range(tstart,Ttot; step=inv(rate)))
  pre = post .- Δt_ro
  return [pre,post]
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">post_pre_spiketrains (generic function with 1 method)</code></pre><p>let&#39;s take a look at one example: rate of 5.0 Hz, 20 ms difference in spike time</p><pre><code class="language-julia hljs">_ = let trains = post_pre_spiketrains(5.0,20E-3,1.0)
  plt = plot()
  scatter!(plt,trains[1], 0.1 .+ zero(trains[1]),markersize=30,
      markercolor=:black,markershape=:vline,leg=false)
  scatter!(plt,trains[2], 0.2 .+ zero(trains[2]),markersize=30,
      markercolor=:black,markershape=:vline,leg=false)
  plot!(plt,ylims=(0.0,0.3),xlims=(0,1),xlabel=&quot;time (s)&quot;)
end</code></pre><img src="cdad4d5c.svg" alt="Example block output"/><p>Now I define a population of input neurons using this input protocol. The Population object includes the weight matrix and the plasticity rules associated to it, both wrapped in the <code>Connection</code> object. I consider the connection as an input parameter of this function, to be set externally with the desired plasticity rule.</p><p>Note that I define the population as <code>PopulationInputTestWeights</code> to indicate non-interacting weights</p><pre><code class="language-julia hljs">function post_pre_population(rate::Real,nreps::Integer,Δt_ro::Real,connection::H.Connection)
  Ttot = nreps/rate
  prepostspikes = post_pre_spiketrains(rate,Δt_ro,Ttot)
  gen = H.SGTrains(prepostspikes)
  state = H.PopulationState(H.InputUnit(gen),2)
  return H.PopulationInputTestWeights(state,connection)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">post_pre_population (generic function with 1 method)</code></pre><h2 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h2><p>Here I define a function that tests the plasticity rule. That is, given a <span>$Δt$</span>, it creates the input neurons, then it defines a network, and iterates it dynamically for a certain number of pre-post repetitions. Finally it outputs the weight total change divided by time (so it&#39;s a weight change per second)</p><p>Since both neurons have the same plasticity rule, a positive pre-post <span>$\Delta t$</span> for neuron A, impacting the  <span>$w_{\text{AB}}$</span> weight, is the equivalent of a negative pre-post <span>$\Delta t$</span> for neuron B, impacting the <span>$w_{\text{BA}}$</span> weight.</p><pre><code class="language-julia hljs">function test_stpd_rule(Δt::Real,connection::H.Connection;
    nreps=510,wstart=100.0,rate=0.5)
  num_spikes = nreps*2 - 10 # a bit less than total, for safety
  recorder = H.RecFullTrain(num_spikes)
  population = post_pre_population(rate,nreps,Δt,connection)
  network = H.RecurrentNetworkExpKernel(population,recorder)
  wmat = connection.weights
  fill!(wmat,wstart)
  wmat[diagind(wmat)] .= 0.0
  t_now = 0.0
  H.reset!.((network,recorder,connection)) # clear spike trains etc
  for _ in 1:num_spikes
    t_now = H.dynamics_step_singlepopulation!(t_now,network)
  end
  w12,w21 = wmat[1,2],wmat[2,1]
  H.reset!(network)
  dw12 = (w12-wstart)/t_now
  dw21 = (w21-wstart)/t_now
  return dw12,dw21
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">test_stpd_rule (generic function with 1 method)</code></pre><h2 id="STDP-rule"><a class="docs-heading-anchor" href="#STDP-rule">STDP rule</a><a id="STDP-rule-1"></a><a class="docs-heading-anchor-permalink" href="#STDP-rule" title="Permalink"></a></h2><p>Here I define the plasticty type and the parameters that I want to test. I choose the pairwise STDP rule. I initialize the weight matrix to 100.0</p><p>Note once again that neurons are not interacting. The sole purpose of the &quot;dummy&quot; weights it to be changed by plasticity.</p><pre><code class="language-julia hljs">connection_test = let wmat =  fill(100.0,2,2)
  wmat[diagind(wmat)] .= 0.0
  τplus = 10E-3
  τminus = 10E-3
  Aplus = 1E-1
  Aminus = -1E-1
  npost,npre = size(wmat)
  stdp_plasticity = H.PairSTDP(τplus,τminus,Aplus,Aminus,npost,npre)
  H.ConnectionDenseWeights(wmat,stdp_plasticity)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">HawkesSimulator.ConnectionDenseWeights{Matrix{Float64}, 1, Tuple{HawkesSimulator.PairSTDP{Float64}}}([0.0 100.0; 100.0 0.0], (HawkesSimulator.PairSTDP{Float64}(0.1, -0.1, HawkesSimulator.Trace{HawkesSimulator.ForPlasticity, Float64}([0.0, 0.0], 0.01, 0.0, HawkesSimulator.ForPlasticity()), HawkesSimulator.Trace{HawkesSimulator.ForPlasticity, Float64}([0.0, 0.0], 0.01, 0.0, HawkesSimulator.ForPlasticity()), HawkesSimulator.PlasticityBoundsNonnegative{Float64}()),))</code></pre><p>let&#39;s do one run</p><pre><code class="language-julia hljs">dw12,dw21 = test_stpd_rule(2E-3,connection_test)
println(&quot;change in w12 : $(dw12), change in w21 $(dw21)&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">change in w12 : -0.04101572643273766, change in w21 0.041015726432737196</code></pre><p>Neuron 1 spikes before neuron 2, therefore connection from 1 to 2, dw21 is potentiated, while connection from 2 to 1, dw12 is depressed.</p><h2 id="STDP-curve"><a class="docs-heading-anchor" href="#STDP-curve">STDP curve</a><a id="STDP-curve-1"></a><a class="docs-heading-anchor-permalink" href="#STDP-curve" title="Permalink"></a></h2><p>Compute and plot the weight changes due to STDP for varying <span>$\Delta t$</span>s</p><pre><code class="language-julia hljs">nsteps = 200
deltats = range(0.1E-3,100E-3;length=nsteps)
deltats_all = vcat(-reverse(deltats),deltats)
out = Vector{Float64}(undef,2*nsteps)

for (i,Δt) in enumerate(deltats)
  dw12,dw21 = test_stpd_rule(Δt,connection_test)
  out[nsteps+i]=dw21
  out[nsteps-i+1]=dw12
end


plot(deltats_all,out;leg=false,xlabel=&quot;Delta t&quot;,ylabel=&quot;dw/dt&quot;,linewidth=3)</code></pre><img src="5629cfd9.svg" alt="Example block output"/><p>Pairing protocol with symmetric STDP rule</p><p>I will do the same as above, but in a slightly different way. I will consider completely random <span>$\Delta t$</span>s values so every single update is different, and I can check all of them at the same time! BUT now I need to save the weights at each step. So I need to store weight at each event! (I can&#39;t use a weight recorder for that, because weight recorder is not event-based, but instead stores the weight according to its internal <span>$\Delta t$</span>)</p><pre><code class="language-julia hljs">function post_pre_spiketrains_morerandom(rate::R,Δt_boundary::R,Ntot::Integer) where R
  tstart = 1.5/rate
  post = collect(range(tstart;length=Ntot,step=inv(rate)))
  Δts  = rand(Uniform(-Δt_boundary,Δt_boundary),Ntot)
  pre = sort!(post .+ Δts)
  return (Δts,[pre,post])
end

function post_pre_population_morerandom(rate::R,
    Δt_boundary::R,Ntot::Integer,connection::H.Connection) where R
  Δts,prepostspikes = post_pre_spiketrains_morerandom(rate,Δt_boundary,Ntot)
  gen = H.SGTrains(prepostspikes)
  state = H.PopulationState(H.InputUnit(gen),2)
  return Δts, H.PopulationInputTestWeights(state,connection)
end

function test_stpd_symmetric_rule(rate::R,
    Δt_boundary::R,Ntot::Integer,connection::H.Connection;
    wstart=100.0) where R
  num_spikes = 2*Ntot
  Δts,population = post_pre_population_morerandom(rate,Δt_boundary,Ntot,connection)
  network = H.RecurrentNetworkExpKernel(population)
  wmat = connection.weights
  ws = Vector{Float64}(undef,num_spikes)
  fill!(wmat,wstart)
  wmat[diagind(wmat)] .= 0.0
  t_now = 0.0
  H.reset!.((network,connection)) # clear spike trains etc
  for k in 1:num_spikes
    t_now = H.dynamics_step_singlepopulation!(t_now,network)
    ws[k] = wmat[1,2]
  end
  Δws = diff(ws)[1:2:end]
  return Δts , ws, Δws
end


myτplus = 10E-3
myτminus = 30E-3
myAplus = 1E-1
myAminus = -0.5E-1

function expected_symm_stdp(Δt::Real)
  return myAplus*exp(-abs(Δt)/myτplus) + myAminus*exp(-abs(Δt)/myτminus)
end

connection_test = let wmat =  fill(100.0,2,2)
  wmat[diagind(wmat)] .= 0.0
  npost,npre = size(wmat)
  stdp_plasticity = H.SymmetricSTDP(myτplus,myτminus,myAplus,myAminus,npost,npre)
  H.ConnectionDenseWeights(wmat,stdp_plasticity)
end

theplot = let myrate = 0.1
  mybound = 100E-3
  myNtest  = 800
  xplot = range(-mybound,mybound,length=150)
  delta_ts,testws, testDws = test_stpd_symmetric_rule(myrate,mybound,myNtest,connection_test)
  scatter(delta_ts,testDws, xlabel=&quot;Delta t&quot;,ylabel=&quot;dw/dt&quot;,
    label=&quot;numeric&quot;, title=&quot;Symmetric STDP&quot;)
  plot!(xplot, expected_symm_stdp.(xplot),linewidth=2,linestyle=:dash,color=:red,
    label=&quot;analytic&quot;)
end

# src</code></pre><img src="536cf461.svg" alt="Example block output"/><h1 id="Fancy-generalized-symmetric-rule"><a class="docs-heading-anchor" href="#Fancy-generalized-symmetric-rule">Fancy generalized symmetric rule</a><a id="Fancy-generalized-symmetric-rule-1"></a><a class="docs-heading-anchor-permalink" href="#Fancy-generalized-symmetric-rule" title="Permalink"></a></h1><p>Here I show a more general symmetric rule that incorporates some bias terms that depend on pre and post firing rate. Some of the functions are re-used from above</p><pre><code class="language-julia hljs">A = -0.1;</code></pre><p>time constants, use γ&gt;1 for long tail with depression</p><pre><code class="language-julia hljs">τ = 10E-3
γ = 3.0;</code></pre><p>The bias on r<em>pre*r</em>post is A*(1+θ) Set to -1.0 for no bias, &gt;-1.0 for negative bias, &lt;-1 for positive bias</p><pre><code class="language-julia hljs">θ = -1.0;</code></pre><p>This is the bias on r_pre</p><pre><code class="language-julia hljs">αpre = -1.0;</code></pre><p>This is the bias on r_post</p><pre><code class="language-julia hljs">αpost = 3.0;

function expected_symmX_stdp(Δt::Real)
  myAplus = A/τ
  myAminus =θ*A/(γ*τ)
  myτplus = τ
  myτminus = γ*τ
  b =  Δt&gt;0 ? A*αpost : A*αpre
  return b + myAplus*exp(-abs(Δt)/myτplus) + myAminus*exp(-abs(Δt)/myτminus)
end

connection_testX = let wmat =  fill(100.0,2,2)
  wmat[diagind(wmat)] .= 0.0
  npost,npre = size(wmat)
  _plasticity = H.PlasticitySymmetricSTDPX(A,θ,τ,γ,αpre,αpost,npost,npre)
  H.ConnectionDenseWeights(wmat,_plasticity)
end

theplot = let myrate = 0.05
  mybound = 100E-3
  myNtest  = 800
  xplot = range(-mybound,mybound,length=150)
  delta_ts,testws, testDws = test_stpd_symmetric_rule(myrate,mybound,myNtest,connection_testX)
  scatter(delta_ts,testDws, xlabel=&quot;Delta t&quot;,ylabel=&quot;dw/dt&quot;,
    label=&quot;numeric&quot;, title=&quot;Generalized Symmetric STDP&quot;)
  plot!(xplot, expected_symmX_stdp.(xplot),linewidth=2,linestyle=:dash,color=:red,
    label=&quot;analytic&quot;)
end</code></pre><img src="d2d807f2.svg" alt="Example block output"/><p>How weird!</p><pre><code class="language-julia hljs"># src</code></pre><p><strong>THE END</strong></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Friday 8 December 2023 12:17">Friday 8 December 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
